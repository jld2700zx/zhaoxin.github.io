{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/oranges/source/iconfont/demo_index.html","path":"iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/iconfont.css","path":"iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/demo.css","path":"iconfont/demo.css","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/iconfont.js","path":"iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/iconfont.json","path":"iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/oranges/source/iconfont/iconfont.woff2","path":"iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/oranges/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/oranges/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/oranges/source/css/base.css","path":"css/base.css","modified":0,"renderable":1},{"_id":"themes/oranges/source/css/github-markdown.css","path":"css/github-markdown.css","modified":0,"renderable":1},{"_id":"themes/oranges/source/js/activeNav.js","path":"js/activeNav.js","modified":0,"renderable":1},{"_id":"themes/oranges/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/oranges/source/js/backtotop.js","path":"js/backtotop.js","modified":0,"renderable":1},{"_id":"themes/oranges/source/js/catalog.js","path":"js/catalog.js","modified":0,"renderable":1},{"_id":"themes/oranges/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/oranges/source/js/search.js","path":"js/search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"3b303f2b090a8cad3019dfe1ac5cceb7697ff314","modified":1615384183723},{"_id":"source/about/index.md","hash":"d940c81ff4dbefd2120907659069e060a13ee417","modified":1615462162910},{"_id":"source/categories/index.md","hash":"7074d9cb00bed014c91d2d89561d9810938af13a","modified":1615374313568},{"_id":"source/_posts/Kafka消费者.md","hash":"523dca489556fefcdc48de33c61597aca816d89c","modified":1615460590486},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1615374164018},{"_id":"source/_posts/.DS_Store","hash":"6832d1d4714092288cc193bb93fc3e4f4891b3ec","modified":1615385093645},{"_id":"source/_posts/WebSocket的使用.md","hash":"4e77b802669d0f89bdbbd735623967d1f978996c","modified":1615386902133},{"_id":"source/_posts/socket-io服务端理解和组件分析.md","hash":"11d2baa60a39040ad34523d4e37d6afe0d73796d","modified":1615385789367},{"_id":"source/_posts/mysql下的join buffer.md","hash":"7b93b572c639c0ee9e314d51642c6172a41e5db0","modified":1615385773638},{"_id":"source/friends/index.md","hash":"6f82ab0f911b113c5ac194b8f756530c8a48ba33","modified":1615352469000},{"_id":"themes/oranges/.gitignore","hash":"986003ff5239d03749d3d3b570671bbb7ffadba6","modified":1615351816000},{"_id":"themes/oranges/_config.yml","hash":"c04c82b38844676507b8ca8cff0aa3cfd795c303","modified":1615353698000},{"_id":"themes/oranges/README.md","hash":"dd3bf1d8d752515ae42e3b50f601b2fa33b454ee","modified":1615351816000},{"_id":"themes/oranges/README-zh.md","hash":"4a3663f135b416c7dcf9337361a2752dea56372c","modified":1615351816000},{"_id":"themes/oranges/languages/de.yml","hash":"72cc121b4a9e18c55623cf8035d288e415841851","modified":1615351816000},{"_id":"themes/oranges/languages/fr.yml","hash":"ac102613f8a7f10b32b6e38d99d5511034733a0d","modified":1615351816000},{"_id":"themes/oranges/.DS_Store","hash":"954655f580c07c6bcf1358a9ef30631620e610d5","modified":1615385088627},{"_id":"themes/oranges/languages/es.yml","hash":"29cf37178f7596fe408cd3234d3addb880608287","modified":1615351816000},{"_id":"themes/oranges/languages/default.yml","hash":"c8740c9a9faafd28d8ba8eb60d28e0160e5f9839","modified":1615351816000},{"_id":"themes/oranges/languages/no.yml","hash":"1c6fd53c378fdd00c2f84ef0af4f61c1f8ea4f8b","modified":1615351816000},{"_id":"themes/oranges/languages/nl.yml","hash":"e6f86d1bc16c916089057e8c8d354983ee839d21","modified":1615351816000},{"_id":"themes/oranges/languages/ja.yml","hash":"08c64794618945b5da0edcc5065e46577fbd5ff3","modified":1615351816000},{"_id":"themes/oranges/languages/ko.yml","hash":"98f150835d5b039cdfe1cf8b32df815d8d763231","modified":1615351816000},{"_id":"themes/oranges/languages/pt.yml","hash":"0719f13aa9f5211400b129d310f517750f4a6e0b","modified":1615351816000},{"_id":"themes/oranges/languages/ru.yml","hash":"ada59b0713fef0e6617a12b20065ce9b24234521","modified":1615351816000},{"_id":"themes/oranges/languages/zh-CN.yml","hash":"3a3b4ade3ffcf5ef330e31d3ce0d69804cfa7c26","modified":1615351816000},{"_id":"themes/oranges/languages/zh-TW.yml","hash":"3d26316a125ea18c64658d4e028351e395e45756","modified":1615351816000},{"_id":"themes/oranges/layout/category.ejs","hash":"ad8ef3de7066f2f7a4d8e603c9ee9ed3e5aa237e","modified":1615351816000},{"_id":"themes/oranges/layout/index.ejs","hash":"492bd5d33bf4a5d8baec1028dd54180d4caec3ef","modified":1615351816000},{"_id":"themes/oranges/layout/archive.ejs","hash":"9c314d52ecb3ea491eb49a27adce76bb0b817ef2","modified":1615351816000},{"_id":"themes/oranges/layout/layout.ejs","hash":"d7178cc05b3afe7196ef348f84553292181db0e6","modified":1615351816000},{"_id":"themes/oranges/source/.DS_Store","hash":"9a015ba823e3c17aa8b5ebeda3f0ba46fd7f487d","modified":1615352832000},{"_id":"themes/oranges/layout/tag.ejs","hash":"2969bf8ba785fa9f592162e3b6fb3e7ae98eba64","modified":1615351816000},{"_id":"themes/oranges/layout/post.ejs","hash":"12b6b596a1343738695e8f5b3864f87f38c14005","modified":1615351816000},{"_id":"themes/oranges/layout/_partial/catalog.ejs","hash":"e2f11cd3d8b90962b9651bd4614161518577261f","modified":1615351816000},{"_id":"themes/oranges/layout/_partial/backtotop.ejs","hash":"a7dfc124629cb256adf26963bb393b89f09a3476","modified":1615351816000},{"_id":"themes/oranges/layout/_partial/comments.ejs","hash":"ae42630259c2a5219b27b1a7167056789e03af14","modified":1615351816000},{"_id":"themes/oranges/layout/_partial/navigation.ejs","hash":"b345ef52f0211b259a051940db044ba33567717d","modified":1615351816000},{"_id":"themes/oranges/layout/_partial/footer.ejs","hash":"973b2aee15aed300ab401dde908dd6814b6a066f","modified":1615351816000},{"_id":"themes/oranges/layout/_partial/search.ejs","hash":"65e972df84a1fd5edceeb68383536c30fbfb59ad","modified":1615351816000},{"_id":"themes/oranges/layout/_partial/header.ejs","hash":"fce510f049285bdb6fc40c5035a0570f4c5c93dd","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/iconfont.eot","hash":"ec8e59b46aee56ebd3fd4bc891fa89b141f8dd77","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/demo_index.html","hash":"db375ad1f08ed3eeeb455771fca147838394551a","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/iconfont.js","hash":"55c291a13445c03d566ac8436103a72806d212a5","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/iconfont.json","hash":"e5b5adc779aee597e4416d5aea66456de7faf41e","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/iconfont.svg","hash":"39b05213c87755919dd16144be63e288c58d9e81","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/iconfont.ttf","hash":"434a4874aca648921248884536c3bf3e15e8ff46","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/iconfont.woff2","hash":"7ef38c1ebe016f9431f1ef5e9ee7348b38a3a3a9","modified":1615351816000},{"_id":"themes/oranges/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1615352867000},{"_id":"themes/oranges/source/css/github-markdown.css","hash":"f78aa3fbbcc5cceab0ee67246b55db8b982c4634","modified":1615351816000},{"_id":"themes/oranges/source/css/highlight.css","hash":"22c32290b22589e69f53cbbd632c77bf398f2130","modified":1615351816000},{"_id":"themes/oranges/source/css/base.css","hash":"63c6cac2d427924ef4150ff9647bbcca547af1f7","modified":1615351816000},{"_id":"themes/oranges/source/js/activeNav.js","hash":"06aa9a2985f1d328f0b7fe69a28bee31f16ebb1a","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/iconfont.css","hash":"1f85622f536e013abf182b0f086aea95f9659cd5","modified":1615351816000},{"_id":"themes/oranges/source/iconfont/iconfont.woff","hash":"97b0996a861db6fdbbc35f40319580273604404b","modified":1615351816000},{"_id":"themes/oranges/source/js/backtotop.js","hash":"7d31a9b613dcaa88e0f4154a62cd0fb2cfe598e8","modified":1615351816000},{"_id":"themes/oranges/source/js/catalog.js","hash":"5617cd7a8bca47debb29ca45e1ec33c84e6603f7","modified":1615351816000},{"_id":"themes/oranges/source/js/search.js","hash":"374efc788268330edd7ca0c91a43e75f7ec4149c","modified":1615351816000},{"_id":"themes/oranges/source/js/fancybox.js","hash":"b217d56f8db94498d7e272d164abac6ab1c07ddd","modified":1615351816000},{"_id":"themes/oranges/LICENSE","hash":"f811cebccc40c019ffd2156f1f15e226e1b86f79","modified":1615351816000},{"_id":"themes/oranges/source/images/favicon.png","hash":"a3e9b196c7623957980cd20f1e8bdc270e30579d","modified":1615346182000},{"_id":"themes/oranges/source/images/avatar.png","hash":"a3e9b196c7623957980cd20f1e8bdc270e30579d","modified":1615346182000},{"_id":"public/categories/index.html","hash":"bbf2765b25c7bdc68a975829a0a1a574ec7ebdf3","modified":1615462413017},{"_id":"public/friends/index.html","hash":"4cc20ac8d861d79fe1d12e41effbc73e29d87d50","modified":1615462413017},{"_id":"public/index.html","hash":"e63fa90e880711c16b1c63552fdee2281dc29551","modified":1615462413017},{"_id":"public/archives/index.html","hash":"6d5287d65d2f1831c9017eeb90604b0840ab8e1e","modified":1615462413017},{"_id":"public/archives/2020/index.html","hash":"0f9092afdaacd2f64e58d005cff22945378e51cd","modified":1615462413017},{"_id":"public/archives/2021/index.html","hash":"d3c0d61692c2ab59aca7bcb71e824920323346f9","modified":1615462413017},{"_id":"public/archives/2021/01/index.html","hash":"0c6a7bedc9f0cf693197be066d82ce6ba4f494bf","modified":1615462413017},{"_id":"public/archives/2021/08/index.html","hash":"f807a4841163abf68ec5786bbae659645dbe278c","modified":1615462413017},{"_id":"public/archives/2020/07/index.html","hash":"dbf77fa76c2a3356a996d2a5d505339d466a438c","modified":1615462413017},{"_id":"public/tags/Kafka/index.html","hash":"d1b3475e6d7addaa5d3d33e0ae8a7267bdeea36c","modified":1615462413017},{"_id":"public/tags/WebSocket/index.html","hash":"f53a11a0e1602e2488121c317d52d78cce0741f9","modified":1615462413017},{"_id":"public/about/index.html","hash":"e43585916a5c0f2ae3a4e34bef3e44923473abda","modified":1615462413017},{"_id":"public/2021/08/10/WebSocket的使用/index.html","hash":"e4f666d4589e8c25d8f8f70c5f0fc009de0bbb14","modified":1615462413017},{"_id":"public/2021/01/10/Kafka消费者/index.html","hash":"cea661990448b5d53b0c61cb5246d7ab28a7cd15","modified":1615462413017},{"_id":"public/2021/08/10/socket-io服务端理解和组件分析/index.html","hash":"31db82bd2a301f871512b602413ff2efe29bccec","modified":1615462413017},{"_id":"public/2020/07/10/mysql下的join buffer/index.html","hash":"962518ad86aaf7da2b80d53ae4cc2badd034e535","modified":1615462413017},{"_id":"public/tags/Netty-Socket-io/index.html","hash":"231069cad35b42b3f14991090b9697879fa93b68","modified":1615462413017},{"_id":"public/tags/Mysql/index.html","hash":"0b1b8c1a3818dfc3f3d6d0e0aa3606863ad28891","modified":1615462413017},{"_id":"public/iconfont/iconfont.ttf","hash":"434a4874aca648921248884536c3bf3e15e8ff46","modified":1615462413017},{"_id":"public/iconfont/iconfont.eot","hash":"ec8e59b46aee56ebd3fd4bc891fa89b141f8dd77","modified":1615462413017},{"_id":"public/iconfont/iconfont.svg","hash":"39b05213c87755919dd16144be63e288c58d9e81","modified":1615462413017},{"_id":"public/iconfont/iconfont.woff2","hash":"7ef38c1ebe016f9431f1ef5e9ee7348b38a3a3a9","modified":1615462413017},{"_id":"public/iconfont/iconfont.woff","hash":"97b0996a861db6fdbbc35f40319580273604404b","modified":1615462413017},{"_id":"public/iconfont/iconfont.css","hash":"1f85622f536e013abf182b0f086aea95f9659cd5","modified":1615462413017},{"_id":"public/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1615462413017},{"_id":"public/iconfont/iconfont.json","hash":"b0951799125e3a304e8993fb687679844ff7043a","modified":1615462413017},{"_id":"public/css/base.css","hash":"63c6cac2d427924ef4150ff9647bbcca547af1f7","modified":1615462413017},{"_id":"public/css/github-markdown.css","hash":"f78aa3fbbcc5cceab0ee67246b55db8b982c4634","modified":1615462413017},{"_id":"public/css/highlight.css","hash":"22c32290b22589e69f53cbbd632c77bf398f2130","modified":1615462413017},{"_id":"public/js/activeNav.js","hash":"06aa9a2985f1d328f0b7fe69a28bee31f16ebb1a","modified":1615462413017},{"_id":"public/js/catalog.js","hash":"5617cd7a8bca47debb29ca45e1ec33c84e6603f7","modified":1615462413017},{"_id":"public/js/fancybox.js","hash":"b217d56f8db94498d7e272d164abac6ab1c07ddd","modified":1615462413017},{"_id":"public/js/search.js","hash":"374efc788268330edd7ca0c91a43e75f7ec4149c","modified":1615462413017},{"_id":"public/js/backtotop.js","hash":"7d31a9b613dcaa88e0f4154a62cd0fb2cfe598e8","modified":1615462413017},{"_id":"public/iconfont/demo_index.html","hash":"db375ad1f08ed3eeeb455771fca147838394551a","modified":1615462413017},{"_id":"public/iconfont/iconfont.js","hash":"55c291a13445c03d566ac8436103a72806d212a5","modified":1615462413017},{"_id":"public/images/avatar.png","hash":"a3e9b196c7623957980cd20f1e8bdc270e30579d","modified":1615462413017},{"_id":"public/images/favicon.png","hash":"a3e9b196c7623957980cd20f1e8bdc270e30579d","modified":1615462413017}],"Category":[],"Data":[],"Page":[{"_content":"### **联系方式**\n\n- 手机：18546916661\n- Email:  187340555@qq.com\n\n### 个人信息\n\n- 姓名：赵鑫\n- 本科/辽宁工业大学/物联网专业\n- 期望职位：Java开发工程师\n- 期望薪资：15k+\n- 个人Blog: http://zhaoxini.github.io\n\n### 开发技能\n\n- Java基础扎实，熟悉Java多线程、jvm原理。\n- 熟悉Spring、 SpringBoot、SpringCloud、Mybatis等框架。\n- 熟悉Mysql关系型数据库、Redis非关系型数据库。\n- 熟悉RabbitMQ\n- 熟悉分布式相关知识。\n- 熟练使用Maven、Git，Junit、Swagger、Jenkins。\n- 了解常用linux命令、docker。\n- 了解Elasticsearch、kafka等框架使用\n- 了解vue、Element-ui等前端框架。\n\n### 资格证书\n\n- 信息系统项目管理师(高级)      /证书编号：31420190521010102577        2019年05月  \n- 软件设计师(中级)                     /证书编号：2018215214100870  \t            2018年11月             \n\n\n\n### 工作经历\n\n##### 用友·新道\t\t   2020年5～至今\n\n- 参与新道云平台专业群建设\n- 参与业务中台建设\n\n**唐山载驰科技有限公司（实习）      2019年7月～2019年11月**\n\n- 负责整个审批流项目后端编码开发工作\n- 协助前端完成部分前端开发工作\n- 参与相关文档编写工作\n\n\n\n### 项目经验\n\n#### ***云平台专业群建设***\n\n> Springboot + SpringCloud + Mybatis + Mysql + Redis\n\n1. 参与需求分析和讨论\n2. 负责教学质量工程功能的开发工作和云平台优化工作\n3. Bug修改和后期维护\n\n项目介绍：\n        项目是用友教育云平台的新版本升级、主要做的功能是专业群共建，旨在建设对专业、专业群进行管理。教务，学生选课等多模块协同共建专业群。本人在项目中负责专业群中教务教学质量工程模块开发工作、 内容主要是包括oa相关功能、教学项目的申报、审批、回退，教学项目进度管理、教学资金管理。同时参与平台优化、包括平台数据字典结构优化、缓存优化。公共组件优化等以及部分产品拆分和迁移工作。\n       本人在该项目中负责教学质量工程整体的数据库设计、接口设计、数据结构设计以及相应功能划分和核心功能的编写工作。\n\n\n\n#### 创业基础教育产品开发\n\n> Springboot + Mybatis-plus+Mysql+Redis+SpringCloud\n\n1. 参与前期需求调研、需求分析\n2. 负责其中有云彩服务的数据库设计和相关编码工作\n3. bug调整和外部系统对接\n4. 项目后期维护\n\n项目介绍：\n\t本项目属于教学产品、服务于学校创业基础教育课程，帮助学生进行创业学习、打磨项目，完善自身定位。\n\t本人负责优化直播评论功能和项目评估模块部分。项目评估模块主要是针对各种选项、各种场景进 行综合评分的过程。直播评论功能主要通过Netty完善了实时评论的功能。本人在该项目中负责数据库设计、程序架构设计、数据结构设计以及项目评估模块核心部分的开发。\n\n****\n\n\n\n### 自我评价\n\n1. 思维逻辑强，善于整体分析，沟通能力好，能够快速融入团队\n2. 能快速融入团队，适应团队。\n3. 1年工作经验，熟悉项目管理流程，需求理解无偏差。\n\n#### 致谢\n\n感谢您花时间阅读我的简历。\n\n","source":"about/index.md","raw":"### **联系方式**\n\n- 手机：18546916661\n- Email:  187340555@qq.com\n\n### 个人信息\n\n- 姓名：赵鑫\n- 本科/辽宁工业大学/物联网专业\n- 期望职位：Java开发工程师\n- 期望薪资：15k+\n- 个人Blog: http://zhaoxini.github.io\n\n### 开发技能\n\n- Java基础扎实，熟悉Java多线程、jvm原理。\n- 熟悉Spring、 SpringBoot、SpringCloud、Mybatis等框架。\n- 熟悉Mysql关系型数据库、Redis非关系型数据库。\n- 熟悉RabbitMQ\n- 熟悉分布式相关知识。\n- 熟练使用Maven、Git，Junit、Swagger、Jenkins。\n- 了解常用linux命令、docker。\n- 了解Elasticsearch、kafka等框架使用\n- 了解vue、Element-ui等前端框架。\n\n### 资格证书\n\n- 信息系统项目管理师(高级)      /证书编号：31420190521010102577        2019年05月  \n- 软件设计师(中级)                     /证书编号：2018215214100870  \t            2018年11月             \n\n\n\n### 工作经历\n\n##### 用友·新道\t\t   2020年5～至今\n\n- 参与新道云平台专业群建设\n- 参与业务中台建设\n\n**唐山载驰科技有限公司（实习）      2019年7月～2019年11月**\n\n- 负责整个审批流项目后端编码开发工作\n- 协助前端完成部分前端开发工作\n- 参与相关文档编写工作\n\n\n\n### 项目经验\n\n#### ***云平台专业群建设***\n\n> Springboot + SpringCloud + Mybatis + Mysql + Redis\n\n1. 参与需求分析和讨论\n2. 负责教学质量工程功能的开发工作和云平台优化工作\n3. Bug修改和后期维护\n\n项目介绍：\n        项目是用友教育云平台的新版本升级、主要做的功能是专业群共建，旨在建设对专业、专业群进行管理。教务，学生选课等多模块协同共建专业群。本人在项目中负责专业群中教务教学质量工程模块开发工作、 内容主要是包括oa相关功能、教学项目的申报、审批、回退，教学项目进度管理、教学资金管理。同时参与平台优化、包括平台数据字典结构优化、缓存优化。公共组件优化等以及部分产品拆分和迁移工作。\n       本人在该项目中负责教学质量工程整体的数据库设计、接口设计、数据结构设计以及相应功能划分和核心功能的编写工作。\n\n\n\n#### 创业基础教育产品开发\n\n> Springboot + Mybatis-plus+Mysql+Redis+SpringCloud\n\n1. 参与前期需求调研、需求分析\n2. 负责其中有云彩服务的数据库设计和相关编码工作\n3. bug调整和外部系统对接\n4. 项目后期维护\n\n项目介绍：\n\t本项目属于教学产品、服务于学校创业基础教育课程，帮助学生进行创业学习、打磨项目，完善自身定位。\n\t本人负责优化直播评论功能和项目评估模块部分。项目评估模块主要是针对各种选项、各种场景进 行综合评分的过程。直播评论功能主要通过Netty完善了实时评论的功能。本人在该项目中负责数据库设计、程序架构设计、数据结构设计以及项目评估模块核心部分的开发。\n\n****\n\n\n\n### 自我评价\n\n1. 思维逻辑强，善于整体分析，沟通能力好，能够快速融入团队\n2. 能快速融入团队，适应团队。\n3. 1年工作经验，熟悉项目管理流程，需求理解无偏差。\n\n#### 致谢\n\n感谢您花时间阅读我的简历。\n\n","date":"2021-03-11T11:29:22.916Z","updated":"2021-03-11T11:29:22.910Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"ckm4slzp700003enp65g812yu","content":"<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a><strong>联系方式</strong></h3><ul>\n<li>手机：18546916661</li>\n<li>Email:  <a href=\"mailto:&#49;&#x38;&#x37;&#51;&#x34;&#x30;&#x35;&#53;&#x35;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;\">&#49;&#x38;&#x37;&#51;&#x34;&#x30;&#x35;&#53;&#x35;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;</a></li>\n</ul>\n<h3 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h3><ul>\n<li>姓名：赵鑫</li>\n<li>本科/辽宁工业大学/物联网专业</li>\n<li>期望职位：Java开发工程师</li>\n<li>期望薪资：15k+</li>\n<li>个人Blog: <a href=\"http://zhaoxini.github.io/\">http://zhaoxini.github.io</a></li>\n</ul>\n<h3 id=\"开发技能\"><a href=\"#开发技能\" class=\"headerlink\" title=\"开发技能\"></a>开发技能</h3><ul>\n<li>Java基础扎实，熟悉Java多线程、jvm原理。</li>\n<li>熟悉Spring、 SpringBoot、SpringCloud、Mybatis等框架。</li>\n<li>熟悉Mysql关系型数据库、Redis非关系型数据库。</li>\n<li>熟悉RabbitMQ</li>\n<li>熟悉分布式相关知识。</li>\n<li>熟练使用Maven、Git，Junit、Swagger、Jenkins。</li>\n<li>了解常用linux命令、docker。</li>\n<li>了解Elasticsearch、kafka等框架使用</li>\n<li>了解vue、Element-ui等前端框架。</li>\n</ul>\n<h3 id=\"资格证书\"><a href=\"#资格证书\" class=\"headerlink\" title=\"资格证书\"></a>资格证书</h3><ul>\n<li>信息系统项目管理师(高级)      /证书编号：31420190521010102577        2019年05月  </li>\n<li>软件设计师(中级)                     /证书编号：2018215214100870                  2018年11月             </li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><h5 id=\"用友·新道-2020年5～至今\"><a href=\"#用友·新道-2020年5～至今\" class=\"headerlink\" title=\"用友·新道           2020年5～至今\"></a>用友·新道           2020年5～至今</h5><ul>\n<li>参与新道云平台专业群建设</li>\n<li>参与业务中台建设</li>\n</ul>\n<p><strong>唐山载驰科技有限公司（实习）      2019年7月～2019年11月</strong></p>\n<ul>\n<li>负责整个审批流项目后端编码开发工作</li>\n<li>协助前端完成部分前端开发工作</li>\n<li>参与相关文档编写工作</li>\n</ul>\n<h3 id=\"项目经验\"><a href=\"#项目经验\" class=\"headerlink\" title=\"项目经验\"></a>项目经验</h3><h4 id=\"云平台专业群建设\"><a href=\"#云平台专业群建设\" class=\"headerlink\" title=\"云平台专业群建设\"></a><em><strong>云平台专业群建设</strong></em></h4><blockquote>\n<p>Springboot + SpringCloud + Mybatis + Mysql + Redis</p>\n</blockquote>\n<ol>\n<li>参与需求分析和讨论</li>\n<li>负责教学质量工程功能的开发工作和云平台优化工作</li>\n<li>Bug修改和后期维护</li>\n</ol>\n<p>项目介绍：<br>        项目是用友教育云平台的新版本升级、主要做的功能是专业群共建，旨在建设对专业、专业群进行管理。教务，学生选课等多模块协同共建专业群。本人在项目中负责专业群中教务教学质量工程模块开发工作、 内容主要是包括oa相关功能、教学项目的申报、审批、回退，教学项目进度管理、教学资金管理。同时参与平台优化、包括平台数据字典结构优化、缓存优化。公共组件优化等以及部分产品拆分和迁移工作。<br>       本人在该项目中负责教学质量工程整体的数据库设计、接口设计、数据结构设计以及相应功能划分和核心功能的编写工作。</p>\n<h4 id=\"创业基础教育产品开发\"><a href=\"#创业基础教育产品开发\" class=\"headerlink\" title=\"创业基础教育产品开发\"></a>创业基础教育产品开发</h4><blockquote>\n<p>Springboot + Mybatis-plus+Mysql+Redis+SpringCloud</p>\n</blockquote>\n<ol>\n<li>参与前期需求调研、需求分析</li>\n<li>负责其中有云彩服务的数据库设计和相关编码工作</li>\n<li>bug调整和外部系统对接</li>\n<li>项目后期维护</li>\n</ol>\n<p>项目介绍：<br>    本项目属于教学产品、服务于学校创业基础教育课程，帮助学生进行创业学习、打磨项目，完善自身定位。<br>    本人负责优化直播评论功能和项目评估模块部分。项目评估模块主要是针对各种选项、各种场景进 行综合评分的过程。直播评论功能主要通过Netty完善了实时评论的功能。本人在该项目中负责数据库设计、程序架构设计、数据结构设计以及项目评估模块核心部分的开发。</p>\n<hr>\n<h3 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h3><ol>\n<li>思维逻辑强，善于整体分析，沟通能力好，能够快速融入团队</li>\n<li>能快速融入团队，适应团队。</li>\n<li>1年工作经验，熟悉项目管理流程，需求理解无偏差。</li>\n</ol>\n<h4 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h4><p>感谢您花时间阅读我的简历。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a><strong>联系方式</strong></h3><ul>\n<li>手机：18546916661</li>\n<li>Email:  <a href=\"mailto:&#49;&#x38;&#x37;&#51;&#x34;&#x30;&#x35;&#53;&#x35;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;\">&#49;&#x38;&#x37;&#51;&#x34;&#x30;&#x35;&#53;&#x35;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;</a></li>\n</ul>\n<h3 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h3><ul>\n<li>姓名：赵鑫</li>\n<li>本科/辽宁工业大学/物联网专业</li>\n<li>期望职位：Java开发工程师</li>\n<li>期望薪资：15k+</li>\n<li>个人Blog: <a href=\"http://zhaoxini.github.io/\">http://zhaoxini.github.io</a></li>\n</ul>\n<h3 id=\"开发技能\"><a href=\"#开发技能\" class=\"headerlink\" title=\"开发技能\"></a>开发技能</h3><ul>\n<li>Java基础扎实，熟悉Java多线程、jvm原理。</li>\n<li>熟悉Spring、 SpringBoot、SpringCloud、Mybatis等框架。</li>\n<li>熟悉Mysql关系型数据库、Redis非关系型数据库。</li>\n<li>熟悉RabbitMQ</li>\n<li>熟悉分布式相关知识。</li>\n<li>熟练使用Maven、Git，Junit、Swagger、Jenkins。</li>\n<li>了解常用linux命令、docker。</li>\n<li>了解Elasticsearch、kafka等框架使用</li>\n<li>了解vue、Element-ui等前端框架。</li>\n</ul>\n<h3 id=\"资格证书\"><a href=\"#资格证书\" class=\"headerlink\" title=\"资格证书\"></a>资格证书</h3><ul>\n<li>信息系统项目管理师(高级)      /证书编号：31420190521010102577        2019年05月  </li>\n<li>软件设计师(中级)                     /证书编号：2018215214100870                  2018年11月             </li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><h5 id=\"用友·新道-2020年5～至今\"><a href=\"#用友·新道-2020年5～至今\" class=\"headerlink\" title=\"用友·新道           2020年5～至今\"></a>用友·新道           2020年5～至今</h5><ul>\n<li>参与新道云平台专业群建设</li>\n<li>参与业务中台建设</li>\n</ul>\n<p><strong>唐山载驰科技有限公司（实习）      2019年7月～2019年11月</strong></p>\n<ul>\n<li>负责整个审批流项目后端编码开发工作</li>\n<li>协助前端完成部分前端开发工作</li>\n<li>参与相关文档编写工作</li>\n</ul>\n<h3 id=\"项目经验\"><a href=\"#项目经验\" class=\"headerlink\" title=\"项目经验\"></a>项目经验</h3><h4 id=\"云平台专业群建设\"><a href=\"#云平台专业群建设\" class=\"headerlink\" title=\"云平台专业群建设\"></a><em><strong>云平台专业群建设</strong></em></h4><blockquote>\n<p>Springboot + SpringCloud + Mybatis + Mysql + Redis</p>\n</blockquote>\n<ol>\n<li>参与需求分析和讨论</li>\n<li>负责教学质量工程功能的开发工作和云平台优化工作</li>\n<li>Bug修改和后期维护</li>\n</ol>\n<p>项目介绍：<br>        项目是用友教育云平台的新版本升级、主要做的功能是专业群共建，旨在建设对专业、专业群进行管理。教务，学生选课等多模块协同共建专业群。本人在项目中负责专业群中教务教学质量工程模块开发工作、 内容主要是包括oa相关功能、教学项目的申报、审批、回退，教学项目进度管理、教学资金管理。同时参与平台优化、包括平台数据字典结构优化、缓存优化。公共组件优化等以及部分产品拆分和迁移工作。<br>       本人在该项目中负责教学质量工程整体的数据库设计、接口设计、数据结构设计以及相应功能划分和核心功能的编写工作。</p>\n<h4 id=\"创业基础教育产品开发\"><a href=\"#创业基础教育产品开发\" class=\"headerlink\" title=\"创业基础教育产品开发\"></a>创业基础教育产品开发</h4><blockquote>\n<p>Springboot + Mybatis-plus+Mysql+Redis+SpringCloud</p>\n</blockquote>\n<ol>\n<li>参与前期需求调研、需求分析</li>\n<li>负责其中有云彩服务的数据库设计和相关编码工作</li>\n<li>bug调整和外部系统对接</li>\n<li>项目后期维护</li>\n</ol>\n<p>项目介绍：<br>    本项目属于教学产品、服务于学校创业基础教育课程，帮助学生进行创业学习、打磨项目，完善自身定位。<br>    本人负责优化直播评论功能和项目评估模块部分。项目评估模块主要是针对各种选项、各种场景进 行综合评分的过程。直播评论功能主要通过Netty完善了实时评论的功能。本人在该项目中负责数据库设计、程序架构设计、数据结构设计以及项目评估模块核心部分的开发。</p>\n<hr>\n<h3 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h3><ol>\n<li>思维逻辑强，善于整体分析，沟通能力好，能够快速融入团队</li>\n<li>能快速融入团队，适应团队。</li>\n<li>1年工作经验，熟悉项目管理流程，需求理解无偏差。</li>\n</ol>\n<h4 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h4><p>感谢您花时间阅读我的简历。</p>\n"},{"title":"categories","date":"2021-03-10T11:05:13.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-03-10 19:05:13\n---\n","updated":"2021-03-10T11:05:13.568Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckm4slzpd00023enpadjo1cp9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"friends","date":"2021-03-10T05:01:09.000Z","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2021-03-10 13:01:09\n---\n","updated":"2021-03-10T05:01:09.000Z","path":"friends/index.html","comments":1,"layout":"page","_id":"ckm4slzpg00053enpelpm9kmc","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Kafka消费者","date":"2021-01-10T14:07:48.000Z","_content":"\n\n\n\n\n\n\n# Kafka消费者\n\n消费者从属于消费群组\n\nKafka分为主题和分区，主题包括分区， 分区是个有序队列。\n\n消费者订阅主题，处理主题里分区的消息。如果想要有序处理，那么就讲消费者和分区进行绑定。\n\n\n\n### 消费者、消费者群组和分区关系\n\n通常，一个主题会对应一个消费群组，消费群组的消费能力取决于消费者的个数。一个消费者对应一个分区或者多个分区。\n\n同一个分区内的消息只能被同一个消费者群组中的一个消费者消费\n\n但是可以被多个消费者群组消费。\n\n消费者 > 分区，消费者过多，有消费者消费能力失效\n\n如果两个消费群组对应一个主题\n\n消费能力就是之前的两倍，但是每个消费者群组里面依然和上面相同\n\n当然，如果消费者能力很强，是可以处理多个分区的。\n\n\n\n消费者群组具有伸缩读取能力和处理能力，群组里的每个消费者只处理部分消息。\n\n如果分区的消息还没处理完，需要转移到另外一个消费者，这个过程就需要再均衡。\n\n\n\n### 再均衡\n\n再均衡的过程就是消费者对分区失去所有权的过程，所以再失去所有权之前要把自己处理记录的偏移量记录下来。\n\nKafka设计了一个再均衡监听器\n\n***ConsumerRebalanceListener.class*** \n\n实现接口的两个方法分别是***#onPartitionsRevoked*** 和 ***#onPartitonsAssigned***\n\nRevoked 是消费者停止读取消息之后被调用，在这里提交最后的偏移量\n\nAssigned 再均衡之后，消费者开始读取消息之前调用。\n\n这里涉及到偏移量提交的问题，偏移量是如何提交的\n\n\n\n再均衡会做一些清理工作\n\n1. 关闭数据库连接\n\n2. 关闭文件具柄\n\n3. 缓冲区遗留的记录\n\n4. ...\n\n   \n\n### 偏移量的提交\n\n#### 同步提交\n\n分为手动提交和自动提交\n\n自动提交\n\n每5s,消费者会自动提交\n\n手动提交就不基于时间间隔，使用commitSync()提交偏移量。\n\n```java\nwhile(true) {\n   try {\n     consumer.commitSycn();\n   }catch(CommitFailedException e) {\n     log.error(\"commit failed\", e);\n   }\n}\n```\n\n\n\n缺点：会限制吞吐量， 降低频率又回带来消息重复的问题\n\n#### 异步提交\n\ncommitAsync();\n\n提交后就反回，虽然解决了上述的问题，但是也带来了新的问题，顺序问题。\n\n如果重试会带来顺序错误问题，就会带来消息重复消费的问题。\n\n\n\n可以通过回调的方式处理\n\n在重试前，先检查回调的序列好和即将提交的偏移量是否相等。相等可以提交，如果序列号偏大，需要停止重试。\n\n\n\n#### 同步和异步组合提交\n\n提交偏移量的重点在于提交最后一个偏移量\n\n组合提交，异步正常提交，同步进行重试\n\n\n\n#### 提交特定偏移量\n\n通过map记录偏移量相关信息。\n\n然后再通过commitAsync或者commitSync尽心提交\n\n\n\n```java\n\n\nConsumerRecords.class //消费者记录\n  \nConsumerRecord records = consumer.poll(100); //拉取100s内的数据返回消费者端\n\nrecords.forEach( record -> {\n  record.offset(); // 偏移量\n  cosummer.commitAsync(...);\n});\n\n\n\n```\n\n\n\n\n\n\n\n","source":"_posts/Kafka消费者.md","raw":"---\ntitle: Kafka消费者\ndate: 2021-01-10 22:07:48\ntags: Kafka\n---\n\n\n\n\n\n\n\n# Kafka消费者\n\n消费者从属于消费群组\n\nKafka分为主题和分区，主题包括分区， 分区是个有序队列。\n\n消费者订阅主题，处理主题里分区的消息。如果想要有序处理，那么就讲消费者和分区进行绑定。\n\n\n\n### 消费者、消费者群组和分区关系\n\n通常，一个主题会对应一个消费群组，消费群组的消费能力取决于消费者的个数。一个消费者对应一个分区或者多个分区。\n\n同一个分区内的消息只能被同一个消费者群组中的一个消费者消费\n\n但是可以被多个消费者群组消费。\n\n消费者 > 分区，消费者过多，有消费者消费能力失效\n\n如果两个消费群组对应一个主题\n\n消费能力就是之前的两倍，但是每个消费者群组里面依然和上面相同\n\n当然，如果消费者能力很强，是可以处理多个分区的。\n\n\n\n消费者群组具有伸缩读取能力和处理能力，群组里的每个消费者只处理部分消息。\n\n如果分区的消息还没处理完，需要转移到另外一个消费者，这个过程就需要再均衡。\n\n\n\n### 再均衡\n\n再均衡的过程就是消费者对分区失去所有权的过程，所以再失去所有权之前要把自己处理记录的偏移量记录下来。\n\nKafka设计了一个再均衡监听器\n\n***ConsumerRebalanceListener.class*** \n\n实现接口的两个方法分别是***#onPartitionsRevoked*** 和 ***#onPartitonsAssigned***\n\nRevoked 是消费者停止读取消息之后被调用，在这里提交最后的偏移量\n\nAssigned 再均衡之后，消费者开始读取消息之前调用。\n\n这里涉及到偏移量提交的问题，偏移量是如何提交的\n\n\n\n再均衡会做一些清理工作\n\n1. 关闭数据库连接\n\n2. 关闭文件具柄\n\n3. 缓冲区遗留的记录\n\n4. ...\n\n   \n\n### 偏移量的提交\n\n#### 同步提交\n\n分为手动提交和自动提交\n\n自动提交\n\n每5s,消费者会自动提交\n\n手动提交就不基于时间间隔，使用commitSync()提交偏移量。\n\n```java\nwhile(true) {\n   try {\n     consumer.commitSycn();\n   }catch(CommitFailedException e) {\n     log.error(\"commit failed\", e);\n   }\n}\n```\n\n\n\n缺点：会限制吞吐量， 降低频率又回带来消息重复的问题\n\n#### 异步提交\n\ncommitAsync();\n\n提交后就反回，虽然解决了上述的问题，但是也带来了新的问题，顺序问题。\n\n如果重试会带来顺序错误问题，就会带来消息重复消费的问题。\n\n\n\n可以通过回调的方式处理\n\n在重试前，先检查回调的序列好和即将提交的偏移量是否相等。相等可以提交，如果序列号偏大，需要停止重试。\n\n\n\n#### 同步和异步组合提交\n\n提交偏移量的重点在于提交最后一个偏移量\n\n组合提交，异步正常提交，同步进行重试\n\n\n\n#### 提交特定偏移量\n\n通过map记录偏移量相关信息。\n\n然后再通过commitAsync或者commitSync尽心提交\n\n\n\n```java\n\n\nConsumerRecords.class //消费者记录\n  \nConsumerRecord records = consumer.poll(100); //拉取100s内的数据返回消费者端\n\nrecords.forEach( record -> {\n  record.offset(); // 偏移量\n  cosummer.commitAsync(...);\n});\n\n\n\n```\n\n\n\n\n\n\n\n","slug":"Kafka消费者","published":1,"updated":"2021-03-11T11:03:10.486Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm4slzpa00013enp8kyahcaz","content":"<h1 id=\"Kafka消费者\"><a href=\"#Kafka消费者\" class=\"headerlink\" title=\"Kafka消费者\"></a>Kafka消费者</h1><p>消费者从属于消费群组</p>\n<p>Kafka分为主题和分区，主题包括分区， 分区是个有序队列。</p>\n<p>消费者订阅主题，处理主题里分区的消息。如果想要有序处理，那么就讲消费者和分区进行绑定。</p>\n<h3 id=\"消费者、消费者群组和分区关系\"><a href=\"#消费者、消费者群组和分区关系\" class=\"headerlink\" title=\"消费者、消费者群组和分区关系\"></a>消费者、消费者群组和分区关系</h3><p>通常，一个主题会对应一个消费群组，消费群组的消费能力取决于消费者的个数。一个消费者对应一个分区或者多个分区。</p>\n<p>同一个分区内的消息只能被同一个消费者群组中的一个消费者消费</p>\n<p>但是可以被多个消费者群组消费。</p>\n<p>消费者 &gt; 分区，消费者过多，有消费者消费能力失效</p>\n<p>如果两个消费群组对应一个主题</p>\n<p>消费能力就是之前的两倍，但是每个消费者群组里面依然和上面相同</p>\n<p>当然，如果消费者能力很强，是可以处理多个分区的。</p>\n<p>消费者群组具有伸缩读取能力和处理能力，群组里的每个消费者只处理部分消息。</p>\n<p>如果分区的消息还没处理完，需要转移到另外一个消费者，这个过程就需要再均衡。</p>\n<h3 id=\"再均衡\"><a href=\"#再均衡\" class=\"headerlink\" title=\"再均衡\"></a>再均衡</h3><p>再均衡的过程就是消费者对分区失去所有权的过程，所以再失去所有权之前要把自己处理记录的偏移量记录下来。</p>\n<p>Kafka设计了一个再均衡监听器</p>\n<p><em><strong>ConsumerRebalanceListener.class</strong></em> </p>\n<p>实现接口的两个方法分别是***#onPartitionsRevoked*** 和 <em><strong>#onPartitonsAssigned</strong></em></p>\n<p>Revoked 是消费者停止读取消息之后被调用，在这里提交最后的偏移量</p>\n<p>Assigned 再均衡之后，消费者开始读取消息之前调用。</p>\n<p>这里涉及到偏移量提交的问题，偏移量是如何提交的</p>\n<p>再均衡会做一些清理工作</p>\n<ol>\n<li><p>关闭数据库连接</p>\n</li>\n<li><p>关闭文件具柄</p>\n</li>\n<li><p>缓冲区遗留的记录</p>\n</li>\n<li><p>…</p>\n</li>\n</ol>\n<h3 id=\"偏移量的提交\"><a href=\"#偏移量的提交\" class=\"headerlink\" title=\"偏移量的提交\"></a>偏移量的提交</h3><h4 id=\"同步提交\"><a href=\"#同步提交\" class=\"headerlink\" title=\"同步提交\"></a>同步提交</h4><p>分为手动提交和自动提交</p>\n<p>自动提交</p>\n<p>每5s,消费者会自动提交</p>\n<p>手动提交就不基于时间间隔，使用commitSync()提交偏移量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     consumer.commitSycn();</span><br><span class=\"line\">   &#125;<span class=\"keyword\">catch</span>(CommitFailedException e) &#123;</span><br><span class=\"line\">     log.error(<span class=\"string\">&quot;commit failed&quot;</span>, e);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>缺点：会限制吞吐量， 降低频率又回带来消息重复的问题</p>\n<h4 id=\"异步提交\"><a href=\"#异步提交\" class=\"headerlink\" title=\"异步提交\"></a>异步提交</h4><p>commitAsync();</p>\n<p>提交后就反回，虽然解决了上述的问题，但是也带来了新的问题，顺序问题。</p>\n<p>如果重试会带来顺序错误问题，就会带来消息重复消费的问题。</p>\n<p>可以通过回调的方式处理</p>\n<p>在重试前，先检查回调的序列好和即将提交的偏移量是否相等。相等可以提交，如果序列号偏大，需要停止重试。</p>\n<h4 id=\"同步和异步组合提交\"><a href=\"#同步和异步组合提交\" class=\"headerlink\" title=\"同步和异步组合提交\"></a>同步和异步组合提交</h4><p>提交偏移量的重点在于提交最后一个偏移量</p>\n<p>组合提交，异步正常提交，同步进行重试</p>\n<h4 id=\"提交特定偏移量\"><a href=\"#提交特定偏移量\" class=\"headerlink\" title=\"提交特定偏移量\"></a>提交特定偏移量</h4><p>通过map记录偏移量相关信息。</p>\n<p>然后再通过commitAsync或者commitSync尽心提交</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ConsumerRecords.class <span class=\"comment\">//消费者记录</span></span><br><span class=\"line\">  </span><br><span class=\"line\">ConsumerRecord records = consumer.poll(<span class=\"number\">100</span>); <span class=\"comment\">//拉取100s内的数据返回消费者端</span></span><br><span class=\"line\"></span><br><span class=\"line\">records.forEach( record -&gt; &#123;</span><br><span class=\"line\">  record.offset(); <span class=\"comment\">// 偏移量</span></span><br><span class=\"line\">  cosummer.commitAsync(...);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Kafka消费者\"><a href=\"#Kafka消费者\" class=\"headerlink\" title=\"Kafka消费者\"></a>Kafka消费者</h1><p>消费者从属于消费群组</p>\n<p>Kafka分为主题和分区，主题包括分区， 分区是个有序队列。</p>\n<p>消费者订阅主题，处理主题里分区的消息。如果想要有序处理，那么就讲消费者和分区进行绑定。</p>\n<h3 id=\"消费者、消费者群组和分区关系\"><a href=\"#消费者、消费者群组和分区关系\" class=\"headerlink\" title=\"消费者、消费者群组和分区关系\"></a>消费者、消费者群组和分区关系</h3><p>通常，一个主题会对应一个消费群组，消费群组的消费能力取决于消费者的个数。一个消费者对应一个分区或者多个分区。</p>\n<p>同一个分区内的消息只能被同一个消费者群组中的一个消费者消费</p>\n<p>但是可以被多个消费者群组消费。</p>\n<p>消费者 &gt; 分区，消费者过多，有消费者消费能力失效</p>\n<p>如果两个消费群组对应一个主题</p>\n<p>消费能力就是之前的两倍，但是每个消费者群组里面依然和上面相同</p>\n<p>当然，如果消费者能力很强，是可以处理多个分区的。</p>\n<p>消费者群组具有伸缩读取能力和处理能力，群组里的每个消费者只处理部分消息。</p>\n<p>如果分区的消息还没处理完，需要转移到另外一个消费者，这个过程就需要再均衡。</p>\n<h3 id=\"再均衡\"><a href=\"#再均衡\" class=\"headerlink\" title=\"再均衡\"></a>再均衡</h3><p>再均衡的过程就是消费者对分区失去所有权的过程，所以再失去所有权之前要把自己处理记录的偏移量记录下来。</p>\n<p>Kafka设计了一个再均衡监听器</p>\n<p><em><strong>ConsumerRebalanceListener.class</strong></em> </p>\n<p>实现接口的两个方法分别是***#onPartitionsRevoked*** 和 <em><strong>#onPartitonsAssigned</strong></em></p>\n<p>Revoked 是消费者停止读取消息之后被调用，在这里提交最后的偏移量</p>\n<p>Assigned 再均衡之后，消费者开始读取消息之前调用。</p>\n<p>这里涉及到偏移量提交的问题，偏移量是如何提交的</p>\n<p>再均衡会做一些清理工作</p>\n<ol>\n<li><p>关闭数据库连接</p>\n</li>\n<li><p>关闭文件具柄</p>\n</li>\n<li><p>缓冲区遗留的记录</p>\n</li>\n<li><p>…</p>\n</li>\n</ol>\n<h3 id=\"偏移量的提交\"><a href=\"#偏移量的提交\" class=\"headerlink\" title=\"偏移量的提交\"></a>偏移量的提交</h3><h4 id=\"同步提交\"><a href=\"#同步提交\" class=\"headerlink\" title=\"同步提交\"></a>同步提交</h4><p>分为手动提交和自动提交</p>\n<p>自动提交</p>\n<p>每5s,消费者会自动提交</p>\n<p>手动提交就不基于时间间隔，使用commitSync()提交偏移量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     consumer.commitSycn();</span><br><span class=\"line\">   &#125;<span class=\"keyword\">catch</span>(CommitFailedException e) &#123;</span><br><span class=\"line\">     log.error(<span class=\"string\">&quot;commit failed&quot;</span>, e);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>缺点：会限制吞吐量， 降低频率又回带来消息重复的问题</p>\n<h4 id=\"异步提交\"><a href=\"#异步提交\" class=\"headerlink\" title=\"异步提交\"></a>异步提交</h4><p>commitAsync();</p>\n<p>提交后就反回，虽然解决了上述的问题，但是也带来了新的问题，顺序问题。</p>\n<p>如果重试会带来顺序错误问题，就会带来消息重复消费的问题。</p>\n<p>可以通过回调的方式处理</p>\n<p>在重试前，先检查回调的序列好和即将提交的偏移量是否相等。相等可以提交，如果序列号偏大，需要停止重试。</p>\n<h4 id=\"同步和异步组合提交\"><a href=\"#同步和异步组合提交\" class=\"headerlink\" title=\"同步和异步组合提交\"></a>同步和异步组合提交</h4><p>提交偏移量的重点在于提交最后一个偏移量</p>\n<p>组合提交，异步正常提交，同步进行重试</p>\n<h4 id=\"提交特定偏移量\"><a href=\"#提交特定偏移量\" class=\"headerlink\" title=\"提交特定偏移量\"></a>提交特定偏移量</h4><p>通过map记录偏移量相关信息。</p>\n<p>然后再通过commitAsync或者commitSync尽心提交</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ConsumerRecords.class <span class=\"comment\">//消费者记录</span></span><br><span class=\"line\">  </span><br><span class=\"line\">ConsumerRecord records = consumer.poll(<span class=\"number\">100</span>); <span class=\"comment\">//拉取100s内的数据返回消费者端</span></span><br><span class=\"line\"></span><br><span class=\"line\">records.forEach( record -&gt; &#123;</span><br><span class=\"line\">  record.offset(); <span class=\"comment\">// 偏移量</span></span><br><span class=\"line\">  cosummer.commitAsync(...);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"title":"WebSocket服务端实现","date":"2021-08-10T14:07:09.000Z","_content":"\n\n\n# WebSocket服务端实现\n\n\n\n## 1. 建立连接\n\n当客户端通过一系列的配置字段（主机（host）、端口（port）、资源名称（resource name）和安全标记（secure））以及一个可被使用的协议（protocol）和扩展（extensions）列表来建立一个WebSocket连接\n\n\n\n## 2. 关闭WebSocket连接\n\n### 关闭原理\n\n关闭tcp连接和tls会话。 tcp关闭才算***彻底***\n\n用一个状态码 `code` （第 7.4 节）和一个可选的关闭原因 `reason` （第 7.1.6 节）来`开始 WebSocket 关闭握手`，\n\n`WebSocket 关闭状态码`被默认为1005。\n\n### 服务端如何关闭\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613888491004-b3205912-ae69-4bb2-82c2-9410fdb212b5.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n如何管理所有的session \n\n通过map\n\n\n\n\n\n## 3. WebSocket 代码实现\n\n### 配置文件\n\n```\n@Configuration\n@EnableWebSocket\npublic class WebSocketConfig{\n    // \n    @Bean\n    public ReverseWebSocketEndpoint reverseWebSocketEndpoint() {\n        return new ReverseWebSocketEndpoint();\n    }\n \n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n \n}\n```\n\n## 客户端建立WebSocket连接测试\n\n前端建立WebSocket连接\n\n在浏览器控制台输入下面标红的语法即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885589624-6db65e08-8609-4ab2-9353-661849c64ef1.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n⚠️：同源问题\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885652515-f90275c9-0050-46ec-84c3-a977abfc7101.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n\n\n\n\n\n\n\n\n## 代码分析\n\n\n\n**ServerEndpointExporter类代码分析**\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613891579226-535abd17-59a1-467f-9828-dbfa87e0d87b.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\nannotatedEndpointClasses是记录带有@*ServerEndpoint的类的一个集合*\n\n这里涉及到**InitializingBean**接口、**WebApplicationObjectSupport**类的使用\n\n\n\n**WebApplicationObjectSupport类，**继承此类可以获取ApplicationContext对象，调用getWebApplicationContext()获取WebApplicationContext\n\n```\n注：spring在代码中获取bean的几种办法\n方法一：在初始化时保存ApplicationContext对象 \n方法二：通过Spring提供的utils类获取ApplicationContext对象 \n方法三：继承自抽象类ApplicationObjectSupport \n方法四：继承自抽象类WebApplicationObjectSupport \n方法五：实现接口ApplicationContextAware \n方法六：通过Spring提供的ContextLoader\n```\n\n注：spring在代码中获取bean的几种办法\n\n方法一：在初始化时保存ApplicationContext对象 方法二：通过Spring提供的utils类获取ApplicationContext对象 方法三：继承自抽象类ApplicationObjectSupport 方法四：继承自抽象类WebApplicationObjectSupport 方法五：实现接口ApplicationContextAware 方法六：通过Spring提供的ContextLoader\n\n\n\n**InitializingBean**接口为bean提供了初始化方法的方式，它只包括**afterPropertiesSet方法**，凡是继承该接口的类，在初始化bean的时候会执行该方法。\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613895411231-35c1eeab-3b5d-458d-bbdf-0b629cc699c3.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n\n\n工具\n\nhttp://coolaf.com/tool/chattest 在线websocket\n\n参考：\n\nhttps://www.cnblogs.com/kiwifly/p/11729304.html  session共享问题","source":"_posts/WebSocket的使用.md","raw":"---\ntitle: WebSocket服务端实现\ndate: 2021-08-10 22:07:09\ntags: WebSocket\n---\n\n\n\n# WebSocket服务端实现\n\n\n\n## 1. 建立连接\n\n当客户端通过一系列的配置字段（主机（host）、端口（port）、资源名称（resource name）和安全标记（secure））以及一个可被使用的协议（protocol）和扩展（extensions）列表来建立一个WebSocket连接\n\n\n\n## 2. 关闭WebSocket连接\n\n### 关闭原理\n\n关闭tcp连接和tls会话。 tcp关闭才算***彻底***\n\n用一个状态码 `code` （第 7.4 节）和一个可选的关闭原因 `reason` （第 7.1.6 节）来`开始 WebSocket 关闭握手`，\n\n`WebSocket 关闭状态码`被默认为1005。\n\n### 服务端如何关闭\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613888491004-b3205912-ae69-4bb2-82c2-9410fdb212b5.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n如何管理所有的session \n\n通过map\n\n\n\n\n\n## 3. WebSocket 代码实现\n\n### 配置文件\n\n```\n@Configuration\n@EnableWebSocket\npublic class WebSocketConfig{\n    // \n    @Bean\n    public ReverseWebSocketEndpoint reverseWebSocketEndpoint() {\n        return new ReverseWebSocketEndpoint();\n    }\n \n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n \n}\n```\n\n## 客户端建立WebSocket连接测试\n\n前端建立WebSocket连接\n\n在浏览器控制台输入下面标红的语法即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885589624-6db65e08-8609-4ab2-9353-661849c64ef1.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n⚠️：同源问题\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885652515-f90275c9-0050-46ec-84c3-a977abfc7101.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n\n\n\n\n\n\n\n\n## 代码分析\n\n\n\n**ServerEndpointExporter类代码分析**\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613891579226-535abd17-59a1-467f-9828-dbfa87e0d87b.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\nannotatedEndpointClasses是记录带有@*ServerEndpoint的类的一个集合*\n\n这里涉及到**InitializingBean**接口、**WebApplicationObjectSupport**类的使用\n\n\n\n**WebApplicationObjectSupport类，**继承此类可以获取ApplicationContext对象，调用getWebApplicationContext()获取WebApplicationContext\n\n```\n注：spring在代码中获取bean的几种办法\n方法一：在初始化时保存ApplicationContext对象 \n方法二：通过Spring提供的utils类获取ApplicationContext对象 \n方法三：继承自抽象类ApplicationObjectSupport \n方法四：继承自抽象类WebApplicationObjectSupport \n方法五：实现接口ApplicationContextAware \n方法六：通过Spring提供的ContextLoader\n```\n\n注：spring在代码中获取bean的几种办法\n\n方法一：在初始化时保存ApplicationContext对象 方法二：通过Spring提供的utils类获取ApplicationContext对象 方法三：继承自抽象类ApplicationObjectSupport 方法四：继承自抽象类WebApplicationObjectSupport 方法五：实现接口ApplicationContextAware 方法六：通过Spring提供的ContextLoader\n\n\n\n**InitializingBean**接口为bean提供了初始化方法的方式，它只包括**afterPropertiesSet方法**，凡是继承该接口的类，在初始化bean的时候会执行该方法。\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1613895411231-35c1eeab-3b5d-458d-bbdf-0b629cc699c3.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n\n\n工具\n\nhttp://coolaf.com/tool/chattest 在线websocket\n\n参考：\n\nhttps://www.cnblogs.com/kiwifly/p/11729304.html  session共享问题","slug":"WebSocket的使用","published":1,"updated":"2021-03-10T14:35:02.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm4slzpd00033enp5shzhww4","content":"<h1 id=\"WebSocket服务端实现\"><a href=\"#WebSocket服务端实现\" class=\"headerlink\" title=\"WebSocket服务端实现\"></a>WebSocket服务端实现</h1><h2 id=\"1-建立连接\"><a href=\"#1-建立连接\" class=\"headerlink\" title=\"1. 建立连接\"></a>1. 建立连接</h2><p>当客户端通过一系列的配置字段（主机（host）、端口（port）、资源名称（resource name）和安全标记（secure））以及一个可被使用的协议（protocol）和扩展（extensions）列表来建立一个WebSocket连接</p>\n<h2 id=\"2-关闭WebSocket连接\"><a href=\"#2-关闭WebSocket连接\" class=\"headerlink\" title=\"2. 关闭WebSocket连接\"></a>2. 关闭WebSocket连接</h2><h3 id=\"关闭原理\"><a href=\"#关闭原理\" class=\"headerlink\" title=\"关闭原理\"></a>关闭原理</h3><p>关闭tcp连接和tls会话。 tcp关闭才算<em><strong>彻底</strong></em></p>\n<p>用一个状态码 <code>code</code> （第 7.4 节）和一个可选的关闭原因 <code>reason</code> （第 7.1.6 节）来<code>开始 WebSocket 关闭握手</code>，</p>\n<p><code>WebSocket 关闭状态码</code>被默认为1005。</p>\n<h3 id=\"服务端如何关闭\"><a href=\"#服务端如何关闭\" class=\"headerlink\" title=\"服务端如何关闭\"></a>服务端如何关闭</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613888491004-b3205912-ae69-4bb2-82c2-9410fdb212b5.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>如何管理所有的session </p>\n<p>通过map</p>\n<h2 id=\"3-WebSocket-代码实现\"><a href=\"#3-WebSocket-代码实现\" class=\"headerlink\" title=\"3. WebSocket 代码实现\"></a>3. WebSocket 代码实现</h2><h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableWebSocket</span><br><span class=\"line\">public class WebSocketConfig&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ReverseWebSocketEndpoint reverseWebSocketEndpoint() &#123;</span><br><span class=\"line\">        return new ReverseWebSocketEndpoint();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class=\"line\">        return new ServerEndpointExporter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"客户端建立WebSocket连接测试\"><a href=\"#客户端建立WebSocket连接测试\" class=\"headerlink\" title=\"客户端建立WebSocket连接测试\"></a>客户端建立WebSocket连接测试</h2><p>前端建立WebSocket连接</p>\n<p>在浏览器控制台输入下面标红的语法即可</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885589624-6db65e08-8609-4ab2-9353-661849c64ef1.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>⚠️：同源问题</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885652515-f90275c9-0050-46ec-84c3-a977abfc7101.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><p><strong>ServerEndpointExporter类代码分析</strong></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613891579226-535abd17-59a1-467f-9828-dbfa87e0d87b.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>annotatedEndpointClasses是记录带有@<em>ServerEndpoint的类的一个集合</em></p>\n<p>这里涉及到<strong>InitializingBean</strong>接口、<strong>WebApplicationObjectSupport</strong>类的使用</p>\n<p><strong>WebApplicationObjectSupport类，</strong>继承此类可以获取ApplicationContext对象，调用getWebApplicationContext()获取WebApplicationContext</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：spring在代码中获取bean的几种办法</span><br><span class=\"line\">方法一：在初始化时保存ApplicationContext对象 </span><br><span class=\"line\">方法二：通过Spring提供的utils类获取ApplicationContext对象 </span><br><span class=\"line\">方法三：继承自抽象类ApplicationObjectSupport </span><br><span class=\"line\">方法四：继承自抽象类WebApplicationObjectSupport </span><br><span class=\"line\">方法五：实现接口ApplicationContextAware </span><br><span class=\"line\">方法六：通过Spring提供的ContextLoader</span><br></pre></td></tr></table></figure>\n\n<p>注：spring在代码中获取bean的几种办法</p>\n<p>方法一：在初始化时保存ApplicationContext对象 方法二：通过Spring提供的utils类获取ApplicationContext对象 方法三：继承自抽象类ApplicationObjectSupport 方法四：继承自抽象类WebApplicationObjectSupport 方法五：实现接口ApplicationContextAware 方法六：通过Spring提供的ContextLoader</p>\n<p><strong>InitializingBean</strong>接口为bean提供了初始化方法的方式，它只包括<strong>afterPropertiesSet方法</strong>，凡是继承该接口的类，在初始化bean的时候会执行该方法。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613895411231-35c1eeab-3b5d-458d-bbdf-0b629cc699c3.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>工具</p>\n<p><a href=\"http://coolaf.com/tool/chattest\">http://coolaf.com/tool/chattest</a> 在线websocket</p>\n<p>参考：</p>\n<p><a href=\"https://www.cnblogs.com/kiwifly/p/11729304.html\">https://www.cnblogs.com/kiwifly/p/11729304.html</a>  session共享问题</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WebSocket服务端实现\"><a href=\"#WebSocket服务端实现\" class=\"headerlink\" title=\"WebSocket服务端实现\"></a>WebSocket服务端实现</h1><h2 id=\"1-建立连接\"><a href=\"#1-建立连接\" class=\"headerlink\" title=\"1. 建立连接\"></a>1. 建立连接</h2><p>当客户端通过一系列的配置字段（主机（host）、端口（port）、资源名称（resource name）和安全标记（secure））以及一个可被使用的协议（protocol）和扩展（extensions）列表来建立一个WebSocket连接</p>\n<h2 id=\"2-关闭WebSocket连接\"><a href=\"#2-关闭WebSocket连接\" class=\"headerlink\" title=\"2. 关闭WebSocket连接\"></a>2. 关闭WebSocket连接</h2><h3 id=\"关闭原理\"><a href=\"#关闭原理\" class=\"headerlink\" title=\"关闭原理\"></a>关闭原理</h3><p>关闭tcp连接和tls会话。 tcp关闭才算<em><strong>彻底</strong></em></p>\n<p>用一个状态码 <code>code</code> （第 7.4 节）和一个可选的关闭原因 <code>reason</code> （第 7.1.6 节）来<code>开始 WebSocket 关闭握手</code>，</p>\n<p><code>WebSocket 关闭状态码</code>被默认为1005。</p>\n<h3 id=\"服务端如何关闭\"><a href=\"#服务端如何关闭\" class=\"headerlink\" title=\"服务端如何关闭\"></a>服务端如何关闭</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613888491004-b3205912-ae69-4bb2-82c2-9410fdb212b5.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>如何管理所有的session </p>\n<p>通过map</p>\n<h2 id=\"3-WebSocket-代码实现\"><a href=\"#3-WebSocket-代码实现\" class=\"headerlink\" title=\"3. WebSocket 代码实现\"></a>3. WebSocket 代码实现</h2><h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableWebSocket</span><br><span class=\"line\">public class WebSocketConfig&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ReverseWebSocketEndpoint reverseWebSocketEndpoint() &#123;</span><br><span class=\"line\">        return new ReverseWebSocketEndpoint();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class=\"line\">        return new ServerEndpointExporter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"客户端建立WebSocket连接测试\"><a href=\"#客户端建立WebSocket连接测试\" class=\"headerlink\" title=\"客户端建立WebSocket连接测试\"></a>客户端建立WebSocket连接测试</h2><p>前端建立WebSocket连接</p>\n<p>在浏览器控制台输入下面标红的语法即可</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885589624-6db65e08-8609-4ab2-9353-661849c64ef1.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>⚠️：同源问题</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885652515-f90275c9-0050-46ec-84c3-a977abfc7101.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><p><strong>ServerEndpointExporter类代码分析</strong></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613891579226-535abd17-59a1-467f-9828-dbfa87e0d87b.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>annotatedEndpointClasses是记录带有@<em>ServerEndpoint的类的一个集合</em></p>\n<p>这里涉及到<strong>InitializingBean</strong>接口、<strong>WebApplicationObjectSupport</strong>类的使用</p>\n<p><strong>WebApplicationObjectSupport类，</strong>继承此类可以获取ApplicationContext对象，调用getWebApplicationContext()获取WebApplicationContext</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：spring在代码中获取bean的几种办法</span><br><span class=\"line\">方法一：在初始化时保存ApplicationContext对象 </span><br><span class=\"line\">方法二：通过Spring提供的utils类获取ApplicationContext对象 </span><br><span class=\"line\">方法三：继承自抽象类ApplicationObjectSupport </span><br><span class=\"line\">方法四：继承自抽象类WebApplicationObjectSupport </span><br><span class=\"line\">方法五：实现接口ApplicationContextAware </span><br><span class=\"line\">方法六：通过Spring提供的ContextLoader</span><br></pre></td></tr></table></figure>\n\n<p>注：spring在代码中获取bean的几种办法</p>\n<p>方法一：在初始化时保存ApplicationContext对象 方法二：通过Spring提供的utils类获取ApplicationContext对象 方法三：继承自抽象类ApplicationObjectSupport 方法四：继承自抽象类WebApplicationObjectSupport 方法五：实现接口ApplicationContextAware 方法六：通过Spring提供的ContextLoader</p>\n<p><strong>InitializingBean</strong>接口为bean提供了初始化方法的方式，它只包括<strong>afterPropertiesSet方法</strong>，凡是继承该接口的类，在初始化bean的时候会执行该方法。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1613895411231-35c1eeab-3b5d-458d-bbdf-0b629cc699c3.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>工具</p>\n<p><a href=\"http://coolaf.com/tool/chattest\">http://coolaf.com/tool/chattest</a> 在线websocket</p>\n<p>参考：</p>\n<p><a href=\"https://www.cnblogs.com/kiwifly/p/11729304.html\">https://www.cnblogs.com/kiwifly/p/11729304.html</a>  session共享问题</p>\n"},{"title":"mysql下的join buffer","date":"2020-07-10T14:07:48.000Z","_content":"\n我们在查询的时候，通过explain可以看到经常有使用join buffer（Using join buffer(Block Nested Loop)\n\n![](https://user-gold-cdn.xitu.io/2020/7/22/17375660c0e7449d?w=2538&h=372&f=png&s=82383)\n\n要想知道join buffer，就是先知道join运行的原理。\n\n## 嵌套循环连接（Nested-Loop Join）\n\n[详细请参考掘金小册《Mysql是怎样运行的》](https://juejin.im/book/6844733769996304392/section/6844733770055024654)\n\njoin的原理就是嵌套循环连接，驱动表作为第一层，被驱动表作为第二层，情况基本如下\n\n```python\nfor 驱动表的每行记录 in 驱动表的记录\n\tfor 被驱动表每行记录 in 被驱动表的记录\n\t\tif (on条件（驱动表的每行记录，被驱动表的每行记录）？return true : false\n```\n\n时间复杂度为 count(驱动表的记录) x count(被驱动表) \n\n比如：有一张课程表course\n\n```java\ncourse                                teacher\n---------------------                 ------------------------\ncourse_id| teacher_id                 teacher_id| teacher_name\n---------------------                 ------------------------\n1        | 1                          1         | leo\n---------------------                 ------------------------\n2        | 2                          2         | john\n---------------------                 ------------------------\n```\n\nsql语句如下\n\n```sql\n select * from course left join teacher \n\ton course.teacher_id = teacher.teacher_id \n\twhere course_id > 0。\n```\n\n因为是左连接，cource为驱动表， teacher为被驱动表。\n\n1. **第一步筛选出驱动表符合条件的记录**\n\n   mysql 查询的时候先根据where条件进行对course的单表查询, 查询出的每一条记录都要在与teacher进行一次查询匹配。例如，where course_id > 0, 那么从course表中拿到第一条记录的时候发现是>0的，可以留下，然后该去teacher表中进行匹配了。\n\n2. **通过连接条件on后的条件对被驱动表的数据筛选**\n\n   第一条的teacher_id 为1，on 条件为teacher_id 相等，也就是我们在teacher表中执行如下的单表查询\n\n   ```java\n   select * from teacher where teacher_id = 1 \n   ```\n\n   那么这条记录如果没有加任何索引，执行中要查询的就是这个teacher表中的所有记录。\n\n**3. 将查询的结果与驱动表进行连接并返回给客户端**\n\n连接就要根据左连接还是右连接进行匹配了，没有的加null值，等等。\n\n## 基于块的嵌套循环连接（Block Nested-Loop Join）\n\n这样一条一条的查就像双重循环，效率低下，被驱动表如果数据量大会出现性能瓶颈。\n\n我们可以思考几个问题：\n\n- 每一条驱动表的记录去被驱动表进行条件匹配的时候，重复匹配了多次，我们是否加个缓存来解决？\n- 缓存的目的是什么？\n- 如果加缓存，这个缓存应该加在哪，驱动表还是被驱动表？\n\n首先我们加缓存的目的是为了取一次数据尽量不被舍弃，可以多次复用。我们查询了很多次被驱动表，如果查询了一次就被缓存下来，在内存中进行数据的匹配操作，效率会高很多。但是会出现一个问题，被驱动表往往是数据量大的一方，被驱动表也可以是多个。所以缓存被驱动表到内存不现实。我们可以反向来想，缓存驱动表。将驱动表的筛选出的所有数据进行缓存，然后每次从被驱动表拿来的数据都与缓存的驱动表的所有记录进行匹配，符合条件的都留下来。这样被驱动表的每条记录只取一次就可以了。\n\n所以join_buffer 就是这个缓冲区，join buffer就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配。join_buffer 就是这个内存块。\n\n![](https://user-gold-cdn.xitu.io/2020/7/22/1737563b590bb0c5?w=826&h=479&f=png&s=104174)\n\n复杂度也从O(n^2) 变成了 O(n)\n\n## MySQL如何使用联接缓冲区缓存\n\n上面所有说的过程都是在被驱动表查询类型是ALL或者Index, 也就是进行全盘扫描，没有加索引，也不是等值连接这种情况下。\n\n[官方文档定义](https://dev.mysql.com/doc/internals/en/join-buffer-size.html)：\n\nBasic information about the join buffer cache:\n\n- The size of each join buffer is determined by the value of the `join_buffer_size` system variable.\n- ***This buffer is used only when the join is of type `ALL` or `index` (in other words, when no possible keys can be used).***\n- A join buffer is never allocated for the first non-const table, even if it would be of type `ALL` or `index`.\n- The buffer is allocated when we need to do a full join between two tables, and freed after the query is done.\n- Accepted row combinations of tables before the `ALL`/`index` are stored in the cache and are used to compare against each read row in the `ALL` table.\n- ***We only store the used columns in the join buffer, not the whole rows.***\n\n上面说，仅仅是在type 为ALL 或者 index 条件下，为什么？\n\n当然是因为使用其他计算方法效率更高，比如我们驱动表进行条件筛选的时候，where teacher_id =1 , 给teacher_id 加上索引就不需要筛选被驱动表中的所有数据，这样的效率更高。只有在Mysql优化器认定type为ALL的时候才**可能**会去用join_buffer\n\n最后一句说：我们仅仅存储使用到的列，而不是整个行\n\njoin_buffer存储的是驱动表中用到的列的数据，比如course表，记录还是两条，但是每条记录里只有teacher_id而没有course_id。\n\n所以要纠正一下上文中的说话，比如记录啊、每一行并不是真的指行里所有的数据，只是需要用到的列的数据。\n\n在看下官方的定义的执行步骤：\n\n假设您具有以下联接：\n\n```sql\nTable name      Type\nt1              range\nt2              ref\nt3              ALL\n```\n\n然后按以下步骤完成连接：\n\n```sql\n- While rows in t1 matching range\n - Read through all rows in t2 according to reference key\n  - Store used fields from t1, t2 in cache\n  - If cache is full\n    - Read through all rows in t3\n      - Compare t3 row against all t1, t2 combinations in cache\n        - If row satisfies join condition, send it to client\n    - Empty cache\n\n- Read through all rows in t3\n - Compare t3 row against all stored t1, t2 combinations in cache\n   - If row satisfies join condition, send it to client\n```\n\n前面的描述意味着`t3`扫描表的次数 确定如下：\n\n```sql\nS = size-of-stored-row(t1,t2)\nC = accepted-row-combinations(t1,t2)\nscans = (S * C)/join_buffer_size + 1\n```\n\nt1 range ,t2 ref ，所以这部分没有用join_buffer，而是将t1和t2匹配的结果缓存在缓冲区\n\n[]()\n\nt3 为all, 读取的时候拿出t3的每一行与t1和t2缓存进行比较。\n\n[]()\n\n扫描的行数为\n\nscans = (S * C)/join_buffer_size + 1\n\n这个join_buffer 也是有一定大小的，如果驱动表> join_buffer，就需要分多次。所以上面要除以/join_buffer_size\n\n## 一些结论\n\nSome conclusions:\n\n- The larger the value of `join_buffer_size`, the fewer the scans of `t3`. If `join_buffer_size` is already large enough to hold all previous row combinations, there is no speed to be gained by making it larger.\n- If there are several tables of join type `ALL` or `index`, then we allocate one buffer of size `join_buffer_size` for each of them and use the same algorithm described above to handle it. (In other words, we store the same row combination several times into different buffers.)\n\n- 值越大`join_buffer_size`，扫描的次数越少`t3`。如果 `join_buffer_size`已经足够大以容纳所有先前的行组合，则使其变大无法获得任何速度。\n- 如果有多个联接类型为`ALL`或的表`index`，则我们`join_buffer_size`为每个表 分配一个大小相同的缓冲区， 并使用上述相同的算法进行处理。（换句话说，我们将同一行组合多次存储到不同的缓冲区中。）\n\n**参考 《MySQL 是怎样运行的：从根儿上理解 MySQL》 作者:小孩子4919**","source":"_posts/mysql下的join buffer.md","raw":"---\ntitle: mysql下的join buffer\ndate: 2020-07-10 22:07:48\ntags: Mysql\n---\n\n我们在查询的时候，通过explain可以看到经常有使用join buffer（Using join buffer(Block Nested Loop)\n\n![](https://user-gold-cdn.xitu.io/2020/7/22/17375660c0e7449d?w=2538&h=372&f=png&s=82383)\n\n要想知道join buffer，就是先知道join运行的原理。\n\n## 嵌套循环连接（Nested-Loop Join）\n\n[详细请参考掘金小册《Mysql是怎样运行的》](https://juejin.im/book/6844733769996304392/section/6844733770055024654)\n\njoin的原理就是嵌套循环连接，驱动表作为第一层，被驱动表作为第二层，情况基本如下\n\n```python\nfor 驱动表的每行记录 in 驱动表的记录\n\tfor 被驱动表每行记录 in 被驱动表的记录\n\t\tif (on条件（驱动表的每行记录，被驱动表的每行记录）？return true : false\n```\n\n时间复杂度为 count(驱动表的记录) x count(被驱动表) \n\n比如：有一张课程表course\n\n```java\ncourse                                teacher\n---------------------                 ------------------------\ncourse_id| teacher_id                 teacher_id| teacher_name\n---------------------                 ------------------------\n1        | 1                          1         | leo\n---------------------                 ------------------------\n2        | 2                          2         | john\n---------------------                 ------------------------\n```\n\nsql语句如下\n\n```sql\n select * from course left join teacher \n\ton course.teacher_id = teacher.teacher_id \n\twhere course_id > 0。\n```\n\n因为是左连接，cource为驱动表， teacher为被驱动表。\n\n1. **第一步筛选出驱动表符合条件的记录**\n\n   mysql 查询的时候先根据where条件进行对course的单表查询, 查询出的每一条记录都要在与teacher进行一次查询匹配。例如，where course_id > 0, 那么从course表中拿到第一条记录的时候发现是>0的，可以留下，然后该去teacher表中进行匹配了。\n\n2. **通过连接条件on后的条件对被驱动表的数据筛选**\n\n   第一条的teacher_id 为1，on 条件为teacher_id 相等，也就是我们在teacher表中执行如下的单表查询\n\n   ```java\n   select * from teacher where teacher_id = 1 \n   ```\n\n   那么这条记录如果没有加任何索引，执行中要查询的就是这个teacher表中的所有记录。\n\n**3. 将查询的结果与驱动表进行连接并返回给客户端**\n\n连接就要根据左连接还是右连接进行匹配了，没有的加null值，等等。\n\n## 基于块的嵌套循环连接（Block Nested-Loop Join）\n\n这样一条一条的查就像双重循环，效率低下，被驱动表如果数据量大会出现性能瓶颈。\n\n我们可以思考几个问题：\n\n- 每一条驱动表的记录去被驱动表进行条件匹配的时候，重复匹配了多次，我们是否加个缓存来解决？\n- 缓存的目的是什么？\n- 如果加缓存，这个缓存应该加在哪，驱动表还是被驱动表？\n\n首先我们加缓存的目的是为了取一次数据尽量不被舍弃，可以多次复用。我们查询了很多次被驱动表，如果查询了一次就被缓存下来，在内存中进行数据的匹配操作，效率会高很多。但是会出现一个问题，被驱动表往往是数据量大的一方，被驱动表也可以是多个。所以缓存被驱动表到内存不现实。我们可以反向来想，缓存驱动表。将驱动表的筛选出的所有数据进行缓存，然后每次从被驱动表拿来的数据都与缓存的驱动表的所有记录进行匹配，符合条件的都留下来。这样被驱动表的每条记录只取一次就可以了。\n\n所以join_buffer 就是这个缓冲区，join buffer就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配。join_buffer 就是这个内存块。\n\n![](https://user-gold-cdn.xitu.io/2020/7/22/1737563b590bb0c5?w=826&h=479&f=png&s=104174)\n\n复杂度也从O(n^2) 变成了 O(n)\n\n## MySQL如何使用联接缓冲区缓存\n\n上面所有说的过程都是在被驱动表查询类型是ALL或者Index, 也就是进行全盘扫描，没有加索引，也不是等值连接这种情况下。\n\n[官方文档定义](https://dev.mysql.com/doc/internals/en/join-buffer-size.html)：\n\nBasic information about the join buffer cache:\n\n- The size of each join buffer is determined by the value of the `join_buffer_size` system variable.\n- ***This buffer is used only when the join is of type `ALL` or `index` (in other words, when no possible keys can be used).***\n- A join buffer is never allocated for the first non-const table, even if it would be of type `ALL` or `index`.\n- The buffer is allocated when we need to do a full join between two tables, and freed after the query is done.\n- Accepted row combinations of tables before the `ALL`/`index` are stored in the cache and are used to compare against each read row in the `ALL` table.\n- ***We only store the used columns in the join buffer, not the whole rows.***\n\n上面说，仅仅是在type 为ALL 或者 index 条件下，为什么？\n\n当然是因为使用其他计算方法效率更高，比如我们驱动表进行条件筛选的时候，where teacher_id =1 , 给teacher_id 加上索引就不需要筛选被驱动表中的所有数据，这样的效率更高。只有在Mysql优化器认定type为ALL的时候才**可能**会去用join_buffer\n\n最后一句说：我们仅仅存储使用到的列，而不是整个行\n\njoin_buffer存储的是驱动表中用到的列的数据，比如course表，记录还是两条，但是每条记录里只有teacher_id而没有course_id。\n\n所以要纠正一下上文中的说话，比如记录啊、每一行并不是真的指行里所有的数据，只是需要用到的列的数据。\n\n在看下官方的定义的执行步骤：\n\n假设您具有以下联接：\n\n```sql\nTable name      Type\nt1              range\nt2              ref\nt3              ALL\n```\n\n然后按以下步骤完成连接：\n\n```sql\n- While rows in t1 matching range\n - Read through all rows in t2 according to reference key\n  - Store used fields from t1, t2 in cache\n  - If cache is full\n    - Read through all rows in t3\n      - Compare t3 row against all t1, t2 combinations in cache\n        - If row satisfies join condition, send it to client\n    - Empty cache\n\n- Read through all rows in t3\n - Compare t3 row against all stored t1, t2 combinations in cache\n   - If row satisfies join condition, send it to client\n```\n\n前面的描述意味着`t3`扫描表的次数 确定如下：\n\n```sql\nS = size-of-stored-row(t1,t2)\nC = accepted-row-combinations(t1,t2)\nscans = (S * C)/join_buffer_size + 1\n```\n\nt1 range ,t2 ref ，所以这部分没有用join_buffer，而是将t1和t2匹配的结果缓存在缓冲区\n\n[]()\n\nt3 为all, 读取的时候拿出t3的每一行与t1和t2缓存进行比较。\n\n[]()\n\n扫描的行数为\n\nscans = (S * C)/join_buffer_size + 1\n\n这个join_buffer 也是有一定大小的，如果驱动表> join_buffer，就需要分多次。所以上面要除以/join_buffer_size\n\n## 一些结论\n\nSome conclusions:\n\n- The larger the value of `join_buffer_size`, the fewer the scans of `t3`. If `join_buffer_size` is already large enough to hold all previous row combinations, there is no speed to be gained by making it larger.\n- If there are several tables of join type `ALL` or `index`, then we allocate one buffer of size `join_buffer_size` for each of them and use the same algorithm described above to handle it. (In other words, we store the same row combination several times into different buffers.)\n\n- 值越大`join_buffer_size`，扫描的次数越少`t3`。如果 `join_buffer_size`已经足够大以容纳所有先前的行组合，则使其变大无法获得任何速度。\n- 如果有多个联接类型为`ALL`或的表`index`，则我们`join_buffer_size`为每个表 分配一个大小相同的缓冲区， 并使用上述相同的算法进行处理。（换句话说，我们将同一行组合多次存储到不同的缓冲区中。）\n\n**参考 《MySQL 是怎样运行的：从根儿上理解 MySQL》 作者:小孩子4919**","slug":"mysql下的join buffer","published":1,"updated":"2021-03-10T14:16:13.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm4slzpg00063enp7poc5yff","content":"<p>我们在查询的时候，通过explain可以看到经常有使用join buffer（Using join buffer(Block Nested Loop)</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/7/22/17375660c0e7449d?w=2538&h=372&f=png&s=82383\"></p>\n<p>要想知道join buffer，就是先知道join运行的原理。</p>\n<h2 id=\"嵌套循环连接（Nested-Loop-Join）\"><a href=\"#嵌套循环连接（Nested-Loop-Join）\" class=\"headerlink\" title=\"嵌套循环连接（Nested-Loop Join）\"></a>嵌套循环连接（Nested-Loop Join）</h2><p><a href=\"https://juejin.im/book/6844733769996304392/section/6844733770055024654\">详细请参考掘金小册《Mysql是怎样运行的》</a></p>\n<p>join的原理就是嵌套循环连接，驱动表作为第一层，被驱动表作为第二层，情况基本如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> 驱动表的每行记录 <span class=\"keyword\">in</span> 驱动表的记录</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> 被驱动表每行记录 <span class=\"keyword\">in</span> 被驱动表的记录</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (on条件（驱动表的每行记录，被驱动表的每行记录）？<span class=\"keyword\">return</span> true : false</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度为 count(驱动表的记录) x count(被驱动表) </p>\n<p>比如：有一张课程表course</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">course                                teacher</span><br><span class=\"line\">---------------------                 ------------------------</span><br><span class=\"line\">course_id| teacher_id                 teacher_id| teacher_name</span><br><span class=\"line\">---------------------                 ------------------------</span><br><span class=\"line\"><span class=\"number\">1</span>        | <span class=\"number\">1</span>                          <span class=\"number\">1</span>         | leo</span><br><span class=\"line\">---------------------                 ------------------------</span><br><span class=\"line\"><span class=\"number\">2</span>        | <span class=\"number\">2</span>                          <span class=\"number\">2</span>         | john</span><br><span class=\"line\">---------------------                 ------------------------</span><br></pre></td></tr></table></figure>\n\n<p>sql语句如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> course <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> teacher </span><br><span class=\"line\"><span class=\"keyword\">on</span> course.teacher_id <span class=\"operator\">=</span> teacher.teacher_id </span><br><span class=\"line\"><span class=\"keyword\">where</span> course_id <span class=\"operator\">&gt;</span> <span class=\"number\">0</span>。</span><br></pre></td></tr></table></figure>\n\n<p>因为是左连接，cource为驱动表， teacher为被驱动表。</p>\n<ol>\n<li><p><strong>第一步筛选出驱动表符合条件的记录</strong></p>\n<p>mysql 查询的时候先根据where条件进行对course的单表查询, 查询出的每一条记录都要在与teacher进行一次查询匹配。例如，where course_id &gt; 0, 那么从course表中拿到第一条记录的时候发现是&gt;0的，可以留下，然后该去teacher表中进行匹配了。</p>\n</li>\n<li><p><strong>通过连接条件on后的条件对被驱动表的数据筛选</strong></p>\n<p>第一条的teacher_id 为1，on 条件为teacher_id 相等，也就是我们在teacher表中执行如下的单表查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from teacher where teacher_id = <span class=\"number\">1</span> </span><br></pre></td></tr></table></figure>\n\n<p>那么这条记录如果没有加任何索引，执行中要查询的就是这个teacher表中的所有记录。</p>\n</li>\n</ol>\n<p><strong>3. 将查询的结果与驱动表进行连接并返回给客户端</strong></p>\n<p>连接就要根据左连接还是右连接进行匹配了，没有的加null值，等等。</p>\n<h2 id=\"基于块的嵌套循环连接（Block-Nested-Loop-Join）\"><a href=\"#基于块的嵌套循环连接（Block-Nested-Loop-Join）\" class=\"headerlink\" title=\"基于块的嵌套循环连接（Block Nested-Loop Join）\"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h2><p>这样一条一条的查就像双重循环，效率低下，被驱动表如果数据量大会出现性能瓶颈。</p>\n<p>我们可以思考几个问题：</p>\n<ul>\n<li>每一条驱动表的记录去被驱动表进行条件匹配的时候，重复匹配了多次，我们是否加个缓存来解决？</li>\n<li>缓存的目的是什么？</li>\n<li>如果加缓存，这个缓存应该加在哪，驱动表还是被驱动表？</li>\n</ul>\n<p>首先我们加缓存的目的是为了取一次数据尽量不被舍弃，可以多次复用。我们查询了很多次被驱动表，如果查询了一次就被缓存下来，在内存中进行数据的匹配操作，效率会高很多。但是会出现一个问题，被驱动表往往是数据量大的一方，被驱动表也可以是多个。所以缓存被驱动表到内存不现实。我们可以反向来想，缓存驱动表。将驱动表的筛选出的所有数据进行缓存，然后每次从被驱动表拿来的数据都与缓存的驱动表的所有记录进行匹配，符合条件的都留下来。这样被驱动表的每条记录只取一次就可以了。</p>\n<p>所以join_buffer 就是这个缓冲区，join buffer就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配。join_buffer 就是这个内存块。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/7/22/1737563b590bb0c5?w=826&h=479&f=png&s=104174\"></p>\n<p>复杂度也从O(n^2) 变成了 O(n)</p>\n<h2 id=\"MySQL如何使用联接缓冲区缓存\"><a href=\"#MySQL如何使用联接缓冲区缓存\" class=\"headerlink\" title=\"MySQL如何使用联接缓冲区缓存\"></a>MySQL如何使用联接缓冲区缓存</h2><p>上面所有说的过程都是在被驱动表查询类型是ALL或者Index, 也就是进行全盘扫描，没有加索引，也不是等值连接这种情况下。</p>\n<p><a href=\"https://dev.mysql.com/doc/internals/en/join-buffer-size.html\">官方文档定义</a>：</p>\n<p>Basic information about the join buffer cache:</p>\n<ul>\n<li>The size of each join buffer is determined by the value of the <code>join_buffer_size</code> system variable.</li>\n<li><em><strong>This buffer is used only when the join is of type <code>ALL</code> or <code>index</code> (in other words, when no possible keys can be used).</strong></em></li>\n<li>A join buffer is never allocated for the first non-const table, even if it would be of type <code>ALL</code> or <code>index</code>.</li>\n<li>The buffer is allocated when we need to do a full join between two tables, and freed after the query is done.</li>\n<li>Accepted row combinations of tables before the <code>ALL</code>/<code>index</code> are stored in the cache and are used to compare against each read row in the <code>ALL</code> table.</li>\n<li><em><strong>We only store the used columns in the join buffer, not the whole rows.</strong></em></li>\n</ul>\n<p>上面说，仅仅是在type 为ALL 或者 index 条件下，为什么？</p>\n<p>当然是因为使用其他计算方法效率更高，比如我们驱动表进行条件筛选的时候，where teacher_id =1 , 给teacher_id 加上索引就不需要筛选被驱动表中的所有数据，这样的效率更高。只有在Mysql优化器认定type为ALL的时候才<strong>可能</strong>会去用join_buffer</p>\n<p>最后一句说：我们仅仅存储使用到的列，而不是整个行</p>\n<p>join_buffer存储的是驱动表中用到的列的数据，比如course表，记录还是两条，但是每条记录里只有teacher_id而没有course_id。</p>\n<p>所以要纠正一下上文中的说话，比如记录啊、每一行并不是真的指行里所有的数据，只是需要用到的列的数据。</p>\n<p>在看下官方的定义的执行步骤：</p>\n<p>假设您具有以下联接：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Table</span> name      Type</span><br><span class=\"line\">t1              <span class=\"keyword\">range</span></span><br><span class=\"line\">t2              <span class=\"keyword\">ref</span></span><br><span class=\"line\">t3              <span class=\"keyword\">ALL</span></span><br></pre></td></tr></table></figure>\n\n<p>然后按以下步骤完成连接：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> While <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> t1 matching <span class=\"keyword\">range</span></span><br><span class=\"line\"> <span class=\"operator\">-</span> Read through <span class=\"keyword\">all</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> t2 according <span class=\"keyword\">to</span> reference key</span><br><span class=\"line\">  <span class=\"operator\">-</span> Store used fields <span class=\"keyword\">from</span> t1, t2 <span class=\"keyword\">in</span> cache</span><br><span class=\"line\">  <span class=\"operator\">-</span> If cache <span class=\"keyword\">is</span> <span class=\"keyword\">full</span></span><br><span class=\"line\">    <span class=\"operator\">-</span> Read through <span class=\"keyword\">all</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> t3</span><br><span class=\"line\">      <span class=\"operator\">-</span> Compare t3 <span class=\"type\">row</span> against <span class=\"keyword\">all</span> t1, t2 combinations <span class=\"keyword\">in</span> cache</span><br><span class=\"line\">        <span class=\"operator\">-</span> If <span class=\"type\">row</span> satisfies <span class=\"keyword\">join</span> <span class=\"keyword\">condition</span>, send it <span class=\"keyword\">to</span> client</span><br><span class=\"line\">    <span class=\"operator\">-</span> <span class=\"keyword\">Empty</span> cache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> Read through <span class=\"keyword\">all</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> t3</span><br><span class=\"line\"> <span class=\"operator\">-</span> Compare t3 <span class=\"type\">row</span> against <span class=\"keyword\">all</span> stored t1, t2 combinations <span class=\"keyword\">in</span> cache</span><br><span class=\"line\">   <span class=\"operator\">-</span> If <span class=\"type\">row</span> satisfies <span class=\"keyword\">join</span> <span class=\"keyword\">condition</span>, send it <span class=\"keyword\">to</span> client</span><br></pre></td></tr></table></figure>\n\n<p>前面的描述意味着<code>t3</code>扫描表的次数 确定如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S <span class=\"operator\">=</span> size<span class=\"operator\">-</span><span class=\"keyword\">of</span><span class=\"operator\">-</span>stored<span class=\"operator\">-</span><span class=\"type\">row</span>(t1,t2)</span><br><span class=\"line\">C <span class=\"operator\">=</span> accepted<span class=\"operator\">-</span><span class=\"type\">row</span><span class=\"operator\">-</span>combinations(t1,t2)</span><br><span class=\"line\">scans <span class=\"operator\">=</span> (S <span class=\"operator\">*</span> C)<span class=\"operator\">/</span>join_buffer_size <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>t1 range ,t2 ref ，所以这部分没有用join_buffer，而是将t1和t2匹配的结果缓存在缓冲区</p>\n<p><a href=\"\"></a></p>\n<p>t3 为all, 读取的时候拿出t3的每一行与t1和t2缓存进行比较。</p>\n<p><a href=\"\"></a></p>\n<p>扫描的行数为</p>\n<p>scans = (S * C)/join_buffer_size + 1</p>\n<p>这个join_buffer 也是有一定大小的，如果驱动表&gt; join_buffer，就需要分多次。所以上面要除以/join_buffer_size</p>\n<h2 id=\"一些结论\"><a href=\"#一些结论\" class=\"headerlink\" title=\"一些结论\"></a>一些结论</h2><p>Some conclusions:</p>\n<ul>\n<li><p>The larger the value of <code>join_buffer_size</code>, the fewer the scans of <code>t3</code>. If <code>join_buffer_size</code> is already large enough to hold all previous row combinations, there is no speed to be gained by making it larger.</p>\n</li>\n<li><p>If there are several tables of join type <code>ALL</code> or <code>index</code>, then we allocate one buffer of size <code>join_buffer_size</code> for each of them and use the same algorithm described above to handle it. (In other words, we store the same row combination several times into different buffers.)</p>\n</li>\n<li><p>值越大<code>join_buffer_size</code>，扫描的次数越少<code>t3</code>。如果 <code>join_buffer_size</code>已经足够大以容纳所有先前的行组合，则使其变大无法获得任何速度。</p>\n</li>\n<li><p>如果有多个联接类型为<code>ALL</code>或的表<code>index</code>，则我们<code>join_buffer_size</code>为每个表 分配一个大小相同的缓冲区， 并使用上述相同的算法进行处理。（换句话说，我们将同一行组合多次存储到不同的缓冲区中。）</p>\n</li>\n</ul>\n<p><strong>参考 《MySQL 是怎样运行的：从根儿上理解 MySQL》 作者:小孩子4919</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们在查询的时候，通过explain可以看到经常有使用join buffer（Using join buffer(Block Nested Loop)</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/7/22/17375660c0e7449d?w=2538&h=372&f=png&s=82383\"></p>\n<p>要想知道join buffer，就是先知道join运行的原理。</p>\n<h2 id=\"嵌套循环连接（Nested-Loop-Join）\"><a href=\"#嵌套循环连接（Nested-Loop-Join）\" class=\"headerlink\" title=\"嵌套循环连接（Nested-Loop Join）\"></a>嵌套循环连接（Nested-Loop Join）</h2><p><a href=\"https://juejin.im/book/6844733769996304392/section/6844733770055024654\">详细请参考掘金小册《Mysql是怎样运行的》</a></p>\n<p>join的原理就是嵌套循环连接，驱动表作为第一层，被驱动表作为第二层，情况基本如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> 驱动表的每行记录 <span class=\"keyword\">in</span> 驱动表的记录</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> 被驱动表每行记录 <span class=\"keyword\">in</span> 被驱动表的记录</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (on条件（驱动表的每行记录，被驱动表的每行记录）？<span class=\"keyword\">return</span> true : false</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度为 count(驱动表的记录) x count(被驱动表) </p>\n<p>比如：有一张课程表course</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">course                                teacher</span><br><span class=\"line\">---------------------                 ------------------------</span><br><span class=\"line\">course_id| teacher_id                 teacher_id| teacher_name</span><br><span class=\"line\">---------------------                 ------------------------</span><br><span class=\"line\"><span class=\"number\">1</span>        | <span class=\"number\">1</span>                          <span class=\"number\">1</span>         | leo</span><br><span class=\"line\">---------------------                 ------------------------</span><br><span class=\"line\"><span class=\"number\">2</span>        | <span class=\"number\">2</span>                          <span class=\"number\">2</span>         | john</span><br><span class=\"line\">---------------------                 ------------------------</span><br></pre></td></tr></table></figure>\n\n<p>sql语句如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> course <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> teacher </span><br><span class=\"line\"><span class=\"keyword\">on</span> course.teacher_id <span class=\"operator\">=</span> teacher.teacher_id </span><br><span class=\"line\"><span class=\"keyword\">where</span> course_id <span class=\"operator\">&gt;</span> <span class=\"number\">0</span>。</span><br></pre></td></tr></table></figure>\n\n<p>因为是左连接，cource为驱动表， teacher为被驱动表。</p>\n<ol>\n<li><p><strong>第一步筛选出驱动表符合条件的记录</strong></p>\n<p>mysql 查询的时候先根据where条件进行对course的单表查询, 查询出的每一条记录都要在与teacher进行一次查询匹配。例如，where course_id &gt; 0, 那么从course表中拿到第一条记录的时候发现是&gt;0的，可以留下，然后该去teacher表中进行匹配了。</p>\n</li>\n<li><p><strong>通过连接条件on后的条件对被驱动表的数据筛选</strong></p>\n<p>第一条的teacher_id 为1，on 条件为teacher_id 相等，也就是我们在teacher表中执行如下的单表查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from teacher where teacher_id = <span class=\"number\">1</span> </span><br></pre></td></tr></table></figure>\n\n<p>那么这条记录如果没有加任何索引，执行中要查询的就是这个teacher表中的所有记录。</p>\n</li>\n</ol>\n<p><strong>3. 将查询的结果与驱动表进行连接并返回给客户端</strong></p>\n<p>连接就要根据左连接还是右连接进行匹配了，没有的加null值，等等。</p>\n<h2 id=\"基于块的嵌套循环连接（Block-Nested-Loop-Join）\"><a href=\"#基于块的嵌套循环连接（Block-Nested-Loop-Join）\" class=\"headerlink\" title=\"基于块的嵌套循环连接（Block Nested-Loop Join）\"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h2><p>这样一条一条的查就像双重循环，效率低下，被驱动表如果数据量大会出现性能瓶颈。</p>\n<p>我们可以思考几个问题：</p>\n<ul>\n<li>每一条驱动表的记录去被驱动表进行条件匹配的时候，重复匹配了多次，我们是否加个缓存来解决？</li>\n<li>缓存的目的是什么？</li>\n<li>如果加缓存，这个缓存应该加在哪，驱动表还是被驱动表？</li>\n</ul>\n<p>首先我们加缓存的目的是为了取一次数据尽量不被舍弃，可以多次复用。我们查询了很多次被驱动表，如果查询了一次就被缓存下来，在内存中进行数据的匹配操作，效率会高很多。但是会出现一个问题，被驱动表往往是数据量大的一方，被驱动表也可以是多个。所以缓存被驱动表到内存不现实。我们可以反向来想，缓存驱动表。将驱动表的筛选出的所有数据进行缓存，然后每次从被驱动表拿来的数据都与缓存的驱动表的所有记录进行匹配，符合条件的都留下来。这样被驱动表的每条记录只取一次就可以了。</p>\n<p>所以join_buffer 就是这个缓冲区，join buffer就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配。join_buffer 就是这个内存块。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/7/22/1737563b590bb0c5?w=826&h=479&f=png&s=104174\"></p>\n<p>复杂度也从O(n^2) 变成了 O(n)</p>\n<h2 id=\"MySQL如何使用联接缓冲区缓存\"><a href=\"#MySQL如何使用联接缓冲区缓存\" class=\"headerlink\" title=\"MySQL如何使用联接缓冲区缓存\"></a>MySQL如何使用联接缓冲区缓存</h2><p>上面所有说的过程都是在被驱动表查询类型是ALL或者Index, 也就是进行全盘扫描，没有加索引，也不是等值连接这种情况下。</p>\n<p><a href=\"https://dev.mysql.com/doc/internals/en/join-buffer-size.html\">官方文档定义</a>：</p>\n<p>Basic information about the join buffer cache:</p>\n<ul>\n<li>The size of each join buffer is determined by the value of the <code>join_buffer_size</code> system variable.</li>\n<li><em><strong>This buffer is used only when the join is of type <code>ALL</code> or <code>index</code> (in other words, when no possible keys can be used).</strong></em></li>\n<li>A join buffer is never allocated for the first non-const table, even if it would be of type <code>ALL</code> or <code>index</code>.</li>\n<li>The buffer is allocated when we need to do a full join between two tables, and freed after the query is done.</li>\n<li>Accepted row combinations of tables before the <code>ALL</code>/<code>index</code> are stored in the cache and are used to compare against each read row in the <code>ALL</code> table.</li>\n<li><em><strong>We only store the used columns in the join buffer, not the whole rows.</strong></em></li>\n</ul>\n<p>上面说，仅仅是在type 为ALL 或者 index 条件下，为什么？</p>\n<p>当然是因为使用其他计算方法效率更高，比如我们驱动表进行条件筛选的时候，where teacher_id =1 , 给teacher_id 加上索引就不需要筛选被驱动表中的所有数据，这样的效率更高。只有在Mysql优化器认定type为ALL的时候才<strong>可能</strong>会去用join_buffer</p>\n<p>最后一句说：我们仅仅存储使用到的列，而不是整个行</p>\n<p>join_buffer存储的是驱动表中用到的列的数据，比如course表，记录还是两条，但是每条记录里只有teacher_id而没有course_id。</p>\n<p>所以要纠正一下上文中的说话，比如记录啊、每一行并不是真的指行里所有的数据，只是需要用到的列的数据。</p>\n<p>在看下官方的定义的执行步骤：</p>\n<p>假设您具有以下联接：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Table</span> name      Type</span><br><span class=\"line\">t1              <span class=\"keyword\">range</span></span><br><span class=\"line\">t2              <span class=\"keyword\">ref</span></span><br><span class=\"line\">t3              <span class=\"keyword\">ALL</span></span><br></pre></td></tr></table></figure>\n\n<p>然后按以下步骤完成连接：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> While <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> t1 matching <span class=\"keyword\">range</span></span><br><span class=\"line\"> <span class=\"operator\">-</span> Read through <span class=\"keyword\">all</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> t2 according <span class=\"keyword\">to</span> reference key</span><br><span class=\"line\">  <span class=\"operator\">-</span> Store used fields <span class=\"keyword\">from</span> t1, t2 <span class=\"keyword\">in</span> cache</span><br><span class=\"line\">  <span class=\"operator\">-</span> If cache <span class=\"keyword\">is</span> <span class=\"keyword\">full</span></span><br><span class=\"line\">    <span class=\"operator\">-</span> Read through <span class=\"keyword\">all</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> t3</span><br><span class=\"line\">      <span class=\"operator\">-</span> Compare t3 <span class=\"type\">row</span> against <span class=\"keyword\">all</span> t1, t2 combinations <span class=\"keyword\">in</span> cache</span><br><span class=\"line\">        <span class=\"operator\">-</span> If <span class=\"type\">row</span> satisfies <span class=\"keyword\">join</span> <span class=\"keyword\">condition</span>, send it <span class=\"keyword\">to</span> client</span><br><span class=\"line\">    <span class=\"operator\">-</span> <span class=\"keyword\">Empty</span> cache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> Read through <span class=\"keyword\">all</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> t3</span><br><span class=\"line\"> <span class=\"operator\">-</span> Compare t3 <span class=\"type\">row</span> against <span class=\"keyword\">all</span> stored t1, t2 combinations <span class=\"keyword\">in</span> cache</span><br><span class=\"line\">   <span class=\"operator\">-</span> If <span class=\"type\">row</span> satisfies <span class=\"keyword\">join</span> <span class=\"keyword\">condition</span>, send it <span class=\"keyword\">to</span> client</span><br></pre></td></tr></table></figure>\n\n<p>前面的描述意味着<code>t3</code>扫描表的次数 确定如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S <span class=\"operator\">=</span> size<span class=\"operator\">-</span><span class=\"keyword\">of</span><span class=\"operator\">-</span>stored<span class=\"operator\">-</span><span class=\"type\">row</span>(t1,t2)</span><br><span class=\"line\">C <span class=\"operator\">=</span> accepted<span class=\"operator\">-</span><span class=\"type\">row</span><span class=\"operator\">-</span>combinations(t1,t2)</span><br><span class=\"line\">scans <span class=\"operator\">=</span> (S <span class=\"operator\">*</span> C)<span class=\"operator\">/</span>join_buffer_size <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>t1 range ,t2 ref ，所以这部分没有用join_buffer，而是将t1和t2匹配的结果缓存在缓冲区</p>\n<p><a href=\"\"></a></p>\n<p>t3 为all, 读取的时候拿出t3的每一行与t1和t2缓存进行比较。</p>\n<p><a href=\"\"></a></p>\n<p>扫描的行数为</p>\n<p>scans = (S * C)/join_buffer_size + 1</p>\n<p>这个join_buffer 也是有一定大小的，如果驱动表&gt; join_buffer，就需要分多次。所以上面要除以/join_buffer_size</p>\n<h2 id=\"一些结论\"><a href=\"#一些结论\" class=\"headerlink\" title=\"一些结论\"></a>一些结论</h2><p>Some conclusions:</p>\n<ul>\n<li><p>The larger the value of <code>join_buffer_size</code>, the fewer the scans of <code>t3</code>. If <code>join_buffer_size</code> is already large enough to hold all previous row combinations, there is no speed to be gained by making it larger.</p>\n</li>\n<li><p>If there are several tables of join type <code>ALL</code> or <code>index</code>, then we allocate one buffer of size <code>join_buffer_size</code> for each of them and use the same algorithm described above to handle it. (In other words, we store the same row combination several times into different buffers.)</p>\n</li>\n<li><p>值越大<code>join_buffer_size</code>，扫描的次数越少<code>t3</code>。如果 <code>join_buffer_size</code>已经足够大以容纳所有先前的行组合，则使其变大无法获得任何速度。</p>\n</li>\n<li><p>如果有多个联接类型为<code>ALL</code>或的表<code>index</code>，则我们<code>join_buffer_size</code>为每个表 分配一个大小相同的缓冲区， 并使用上述相同的算法进行处理。（换句话说，我们将同一行组合多次存储到不同的缓冲区中。）</p>\n</li>\n</ul>\n<p><strong>参考 《MySQL 是怎样运行的：从根儿上理解 MySQL》 作者:小孩子4919</strong></p>\n"},{"title":"socket.io服务端理解和组件分析","date":"2021-08-10T14:07:09.000Z","_content":"\n\n\n## 回顾Socket\n\nSocket建立请求和处理数据的过程\n\n### 一个客户端\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838003875-4ba0c7b8-51cb-448c-a826-f73ada176fa9.png)\n\n\n\n整个过程服务端都是一个线程在做，客户端发来请求，服务端accpet()接受请求，read(), write()处理数据， 处理完数据关闭连接、释放线程。\n\n### 多个客户端\n\n如果多个客户端怎么办？\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838158237-31c32765-eaa7-462b-b864-7b21a0a0e90a.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n那就每一个客户端创建一个线程。新建一个线程专门用来监听，有新客户端就new一个新的线程。\n\n我们还可以优化一下，**池化思想**。将new Thread这个过程变成， 从pool线程池里面获取，让很多线程不随着连接关闭，多次复用。\n\n这就出现了NIO优化的地方\n\n\n\n### NIO非阻塞思想\n\nNIO 三个关键组件  Selector、Buffer、Channel\n\n\n\nSelector有点像我们上面图的监听线程，他的作用就是从线程池里面找到空闲的线程来处理客户端的请求。\n\nSelector充当中间分配任务的角色，所有客户端线程、服务端线程都注册到我这，我帮你们进行分配，进行多路复用。\n\n线程池里面的线程会轮询去Selector中找感兴趣的事，不会绑定某个连接上，read()、write()事件处理完就继续找下一个连接要处理的事情，等到上一个连接有新的数据再返回处理。\n\n\n\nChannel、Buffer改变传统流的方式，能够更好管理数据，提高效率。\n\n\n\n\n\n## Netty基础概念和代码\n\nNetty就是对NIO的使用进行了简化，又优化了很多地方。但是核心思想还是不变的，还是采用Channel和Buffer这种结构。\n\nNetty将Channel中加入ChannelHandler这种组件，它负责调度应用程序的处理逻辑，并驱动数据和事件经过网络层。简单来说就是加入了带有方向的拦截器，用来处理数据。\n\nBuffer也变成了ByteBuf。\n\n为了简化nio使用，Netty使用了**BootStrap启动器**用来辅助进行建立**socket连接**、**创建Channel通道**等等这些操作，设计模式用的是构建者模式。\n\n\n\n同时还有**EventLoop**用来管理所有的Channel，这里的**EventLoop**可以理解为上面图的**监控线程**、或者是**工作线程**这种线程。EventLoopGroup就是线程池，所以我们的工作线程要有线程池，这就是Netty代码里面的 NioEventLoopGroup **work** = new NioEventLoopGroup(); 同样，如果监控线程如果监控的是一个端口可以只用一个线程、如果是多个端口那就要用线程池了。所以在Netty中就出现了boss这种线程池（NioEventLoopGroup **boss** = new NioEventLoopGroup(); ）\n\n\n\nNetty的学习首先要搞清楚它的架构、设计模式。\n\n清楚他的各个组件的作用和关系，如图：\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614835289260-6477f02f-b166-43dc-9370-441899d5f036.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n如果你认为 ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的 Channel- Handler 实例链，是ChannelHandler的容器。\n\n\n\nNetty在Channel里传输的数据是ByteBuf，所以我们要将客户端和服务端所接受的数据都转化为ByteBuf，这就涉及到了一个Netty的重要部分，编码和解码。\n\n\n\n还有就是ChannelHandlerContext，是ChannelHandler上下文内容，ChannelHandler处理完的数据都是ChannelHandlerContext来传输下一个ChannelHandler。ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关 联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandler- Context。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在 同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。\n\n\n\n使用Netty大致的过程就是：\n\n1. 创建Bootstrap启动器\n2. 创建监控线程组boss和工作线程组work。（客户端不用boss)\n3. 用Bootstrap建立Channel，添加ChannelHanlder拦截器\n4. 客户端用Bootstrap连接服务端。服务端用Bootstrap绑定端口开启监听\n\n### 服务端\n\n\n\n```\npublic class NettyServer {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n\n        NioEventLoopGroup work = new NioEventLoopGroup();\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n\n        bootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new DecoderHandler());\n                        ch.pipeline().addLast(new ServerInHandler());\n                    }\n                });\n\n        ChannelFuture future = bootstrap.bind(1000).addListener((listener) -> {\n            if (listener.isSuccess()) {\n                System.out.println(\"服务器启动成功\");\n            }\n        });\n    }\n\n}\n```\n\n### 客户端\n\n\n\n```\n# NettyClient.java\n/**\n * Netty客户端\n */\npublic class NettyClient {\n\n    Bootstrap bootstrap = new Bootstrap();\n\n    EventLoopGroup work;\n\n    public boolean connect(String inetHost, Integer inetPort) throws InterruptedException {\n        work = new NioEventLoopGroup();\n        bootstrap.group(work)\n                .channel(NioSocketChannel.class) //\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new EncoderHandler());\n                        ch.pipeline().addLast(new ClientInHandler());\n                    }\n                });\n            bootstrap.connect(inetHost, inetPort).addListener((listener) -> {\n                if (listener.isSuccess()) {\n                    System.out.println(\"连接成功\");\n                    ChannelFuture future = (ChannelFuture) listener;\n                    startConsoleThread(future.channel());  // 开启控制台线程\n                }\n            });\n            return true;\n\n    }\n}\n```\n\n\n\n## socketio实例分析\n\n分析的是github上socketio这个项目 https://github.com/mrniko/netty-socketio/\n\nSocket.IO server implemented on Java. Realtime java framework\n\n用netty实现的实时网络通信\n\n\n\n\n\n### 模块分析\n\n#### Namespace\n\n在一个命名空间空间的所有客户端都是共享的\n\n那共享的都有什么呢？一个一个分析\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614920618711-1ada87d2-c22c-424a-a609-0c98624dbbfa.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n\n\n先看ScannerEngine类内容\n\n```\n# ScannerEngine.class\n    \npublic void scan(Namespace namespace, Object object, Class<?> clazz)\n            throws IllegalArgumentException {\n        Method[] methods = clazz.getDeclaredMethods();\n\n        // 类不是Object类型的\n        if (!clazz.isAssignableFrom(object.getClass())) {\n            for (Method method : methods) {\n                for (AnnotationScanner annotationScanner : annotations) {\n                    Annotation ann = method.getAnnotation(annotationScanner.getScanAnnotation());\n                    if (ann != null) {\n                        annotationScanner.validate(method, clazz);\n\n                        Method m = findSimilarMethod(object.getClass(), method);\n                        if (m != null) {\n                            annotationScanner.addListener(namespace, object, m, ann);\n                        } else {\n                            log.warn(\"Method similar to \" + method.getName() + \" can't be found in \" + object.getClass());\n                        }\n                    }\n                }\n            }\n            // -----------------主要看这段--------------------------\n        } else {\n            for (Method method : methods) {\n                for (AnnotationScanner annotationScanner : annotations) {\n                    Annotation ann = method.getAnnotation(annotationScanner.getScanAnnotation());\n                    if (ann != null) {\n                        annotationScanner.validate(method, clazz);\n                        makeAccessible(method);\n                        annotationScanner.addListener(namespace, object, method, ann);\n                    }\n                }\n            }\n         // -----------------end--------------------------\n            if (clazz.getSuperclass() != null) {\n                scan(namespace, object, clazz.getSuperclass());\n            } else if (clazz.isInterface()) {\n                for (Class<?> superIfc : clazz.getInterfaces()) {\n                    scan(namespace, object, superIfc);\n                }\n            }\n        }\n\n    }\n```\n\n先说这段代码干嘛的，去扫描类里面的方法，有没有带有这三个注解的方法，如果有的话，把相应的下图三个监听器添加到相应命名空间下的执行队列中。\n\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921713851-7997ddad-d955-4573-b8d9-0967228615f4.png)![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921813582-a02626b3-2473-42f9-832a-0424577f9a92.png)\n\n所以ScannerEngine类就是扫描注解，然后添加监听器。加个上面三个注解的方法都会添加到监听器中。\n\nNameSpace这个对象拿着ScannerEngine引擎去查找带注解的方法，并添加到NameSpace中。\n\n\n\neventListeners、connectListeners、disconnectListeners\n\n这三个就不要特别说明了，是三个不同类别的监听器，分别在不同时期进行执行。\n\npingListeners也是同理\n\n\n\nallClients是在这个命名空间下所有的客户端， SocketIOClient是客户端实体\n\nroomClients是房间内的客户端，就算是分组把\n\nclientRooms是房间，也就是组。可以移除客户端也可以添加。\n\n\n\n\n\n#### NameSpaceHub\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923575816-c1e9f0ca-b3e7-4941-84c3-85bbe741e7c1.png)\n\n用来操作NameSpaceHub的，主要是创建、获取移除等等，同时可以看到所有的NameSpace。\n\n\n\n#### Protocol\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923846574-f407d315-a478-4bcf-878d-5cbf561b1fb3.png)\n\n因为在使用Netty过程中我们要自定义协议格式，这里Packet就是数据协议包，AuthPacket是一个认证的协议包。\n\n剩下都是围绕Packet的一些工具。比如PacketDecoder或者PacketEncoder这种编码解码工具、Json序列化的工具等等。\n\n重点说下Packet包\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923992993-0a7ce29c-e754-48ef-bf3c-ef7b1fae200b.png?x-oss-process=image%2Fresize%2Cw_1500)\n\ndata数据、nsp命名空间、ackId唯一标识，可能用于消息确认等其他用途、type、subType都是包的类型\n\n包的类型又分为下面这些\n\n\n\n***#PacketType.java***\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924404084-776ee465-968b-4e16-ab5c-0cd87dc67832.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n类型Connect、Disconnect或者是Event或者是Ackd等等\n\n\n\n回到上图这个attachments我也没明白，应该是可以自定义的一些字段，附件，方便扩展。同时还需要进行初始化\n\n***#Packet.java***\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924500498-1170a570-9d64-40cc-89fe-535e6b8bc16c.png)\n\n\n\nPacket包里面的数据就是data，data经过***#PacketEncoder***编码后就变了ByteBuf，Netty就可以在Channel中传输了，下图是编码的过程\n\n***#PacketEncoder.java***\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614925102874-bfc4aba2-6291-45c2-b661-6c9f2ac75d16.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n#### Listener\n\n.... 未完待续\n\n#####  ","source":"_posts/socket-io服务端理解和组件分析.md","raw":"---\ntitle: socket.io服务端理解和组件分析\ndate: 2021-08-10 22:07:09\ntags: Netty Socket.io\n---\n\n\n\n## 回顾Socket\n\nSocket建立请求和处理数据的过程\n\n### 一个客户端\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838003875-4ba0c7b8-51cb-448c-a826-f73ada176fa9.png)\n\n\n\n整个过程服务端都是一个线程在做，客户端发来请求，服务端accpet()接受请求，read(), write()处理数据， 处理完数据关闭连接、释放线程。\n\n### 多个客户端\n\n如果多个客户端怎么办？\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838158237-31c32765-eaa7-462b-b864-7b21a0a0e90a.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n那就每一个客户端创建一个线程。新建一个线程专门用来监听，有新客户端就new一个新的线程。\n\n我们还可以优化一下，**池化思想**。将new Thread这个过程变成， 从pool线程池里面获取，让很多线程不随着连接关闭，多次复用。\n\n这就出现了NIO优化的地方\n\n\n\n### NIO非阻塞思想\n\nNIO 三个关键组件  Selector、Buffer、Channel\n\n\n\nSelector有点像我们上面图的监听线程，他的作用就是从线程池里面找到空闲的线程来处理客户端的请求。\n\nSelector充当中间分配任务的角色，所有客户端线程、服务端线程都注册到我这，我帮你们进行分配，进行多路复用。\n\n线程池里面的线程会轮询去Selector中找感兴趣的事，不会绑定某个连接上，read()、write()事件处理完就继续找下一个连接要处理的事情，等到上一个连接有新的数据再返回处理。\n\n\n\nChannel、Buffer改变传统流的方式，能够更好管理数据，提高效率。\n\n\n\n\n\n## Netty基础概念和代码\n\nNetty就是对NIO的使用进行了简化，又优化了很多地方。但是核心思想还是不变的，还是采用Channel和Buffer这种结构。\n\nNetty将Channel中加入ChannelHandler这种组件，它负责调度应用程序的处理逻辑，并驱动数据和事件经过网络层。简单来说就是加入了带有方向的拦截器，用来处理数据。\n\nBuffer也变成了ByteBuf。\n\n为了简化nio使用，Netty使用了**BootStrap启动器**用来辅助进行建立**socket连接**、**创建Channel通道**等等这些操作，设计模式用的是构建者模式。\n\n\n\n同时还有**EventLoop**用来管理所有的Channel，这里的**EventLoop**可以理解为上面图的**监控线程**、或者是**工作线程**这种线程。EventLoopGroup就是线程池，所以我们的工作线程要有线程池，这就是Netty代码里面的 NioEventLoopGroup **work** = new NioEventLoopGroup(); 同样，如果监控线程如果监控的是一个端口可以只用一个线程、如果是多个端口那就要用线程池了。所以在Netty中就出现了boss这种线程池（NioEventLoopGroup **boss** = new NioEventLoopGroup(); ）\n\n\n\nNetty的学习首先要搞清楚它的架构、设计模式。\n\n清楚他的各个组件的作用和关系，如图：\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614835289260-6477f02f-b166-43dc-9370-441899d5f036.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n如果你认为 ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的 Channel- Handler 实例链，是ChannelHandler的容器。\n\n\n\nNetty在Channel里传输的数据是ByteBuf，所以我们要将客户端和服务端所接受的数据都转化为ByteBuf，这就涉及到了一个Netty的重要部分，编码和解码。\n\n\n\n还有就是ChannelHandlerContext，是ChannelHandler上下文内容，ChannelHandler处理完的数据都是ChannelHandlerContext来传输下一个ChannelHandler。ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关 联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandler- Context。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在 同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。\n\n\n\n使用Netty大致的过程就是：\n\n1. 创建Bootstrap启动器\n2. 创建监控线程组boss和工作线程组work。（客户端不用boss)\n3. 用Bootstrap建立Channel，添加ChannelHanlder拦截器\n4. 客户端用Bootstrap连接服务端。服务端用Bootstrap绑定端口开启监听\n\n### 服务端\n\n\n\n```\npublic class NettyServer {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n\n        NioEventLoopGroup work = new NioEventLoopGroup();\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n\n        bootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new DecoderHandler());\n                        ch.pipeline().addLast(new ServerInHandler());\n                    }\n                });\n\n        ChannelFuture future = bootstrap.bind(1000).addListener((listener) -> {\n            if (listener.isSuccess()) {\n                System.out.println(\"服务器启动成功\");\n            }\n        });\n    }\n\n}\n```\n\n### 客户端\n\n\n\n```\n# NettyClient.java\n/**\n * Netty客户端\n */\npublic class NettyClient {\n\n    Bootstrap bootstrap = new Bootstrap();\n\n    EventLoopGroup work;\n\n    public boolean connect(String inetHost, Integer inetPort) throws InterruptedException {\n        work = new NioEventLoopGroup();\n        bootstrap.group(work)\n                .channel(NioSocketChannel.class) //\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new EncoderHandler());\n                        ch.pipeline().addLast(new ClientInHandler());\n                    }\n                });\n            bootstrap.connect(inetHost, inetPort).addListener((listener) -> {\n                if (listener.isSuccess()) {\n                    System.out.println(\"连接成功\");\n                    ChannelFuture future = (ChannelFuture) listener;\n                    startConsoleThread(future.channel());  // 开启控制台线程\n                }\n            });\n            return true;\n\n    }\n}\n```\n\n\n\n## socketio实例分析\n\n分析的是github上socketio这个项目 https://github.com/mrniko/netty-socketio/\n\nSocket.IO server implemented on Java. Realtime java framework\n\n用netty实现的实时网络通信\n\n\n\n\n\n### 模块分析\n\n#### Namespace\n\n在一个命名空间空间的所有客户端都是共享的\n\n那共享的都有什么呢？一个一个分析\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614920618711-1ada87d2-c22c-424a-a609-0c98624dbbfa.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n\n\n先看ScannerEngine类内容\n\n```\n# ScannerEngine.class\n    \npublic void scan(Namespace namespace, Object object, Class<?> clazz)\n            throws IllegalArgumentException {\n        Method[] methods = clazz.getDeclaredMethods();\n\n        // 类不是Object类型的\n        if (!clazz.isAssignableFrom(object.getClass())) {\n            for (Method method : methods) {\n                for (AnnotationScanner annotationScanner : annotations) {\n                    Annotation ann = method.getAnnotation(annotationScanner.getScanAnnotation());\n                    if (ann != null) {\n                        annotationScanner.validate(method, clazz);\n\n                        Method m = findSimilarMethod(object.getClass(), method);\n                        if (m != null) {\n                            annotationScanner.addListener(namespace, object, m, ann);\n                        } else {\n                            log.warn(\"Method similar to \" + method.getName() + \" can't be found in \" + object.getClass());\n                        }\n                    }\n                }\n            }\n            // -----------------主要看这段--------------------------\n        } else {\n            for (Method method : methods) {\n                for (AnnotationScanner annotationScanner : annotations) {\n                    Annotation ann = method.getAnnotation(annotationScanner.getScanAnnotation());\n                    if (ann != null) {\n                        annotationScanner.validate(method, clazz);\n                        makeAccessible(method);\n                        annotationScanner.addListener(namespace, object, method, ann);\n                    }\n                }\n            }\n         // -----------------end--------------------------\n            if (clazz.getSuperclass() != null) {\n                scan(namespace, object, clazz.getSuperclass());\n            } else if (clazz.isInterface()) {\n                for (Class<?> superIfc : clazz.getInterfaces()) {\n                    scan(namespace, object, superIfc);\n                }\n            }\n        }\n\n    }\n```\n\n先说这段代码干嘛的，去扫描类里面的方法，有没有带有这三个注解的方法，如果有的话，把相应的下图三个监听器添加到相应命名空间下的执行队列中。\n\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921713851-7997ddad-d955-4573-b8d9-0967228615f4.png)![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921813582-a02626b3-2473-42f9-832a-0424577f9a92.png)\n\n所以ScannerEngine类就是扫描注解，然后添加监听器。加个上面三个注解的方法都会添加到监听器中。\n\nNameSpace这个对象拿着ScannerEngine引擎去查找带注解的方法，并添加到NameSpace中。\n\n\n\neventListeners、connectListeners、disconnectListeners\n\n这三个就不要特别说明了，是三个不同类别的监听器，分别在不同时期进行执行。\n\npingListeners也是同理\n\n\n\nallClients是在这个命名空间下所有的客户端， SocketIOClient是客户端实体\n\nroomClients是房间内的客户端，就算是分组把\n\nclientRooms是房间，也就是组。可以移除客户端也可以添加。\n\n\n\n\n\n#### NameSpaceHub\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923575816-c1e9f0ca-b3e7-4941-84c3-85bbe741e7c1.png)\n\n用来操作NameSpaceHub的，主要是创建、获取移除等等，同时可以看到所有的NameSpace。\n\n\n\n#### Protocol\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923846574-f407d315-a478-4bcf-878d-5cbf561b1fb3.png)\n\n因为在使用Netty过程中我们要自定义协议格式，这里Packet就是数据协议包，AuthPacket是一个认证的协议包。\n\n剩下都是围绕Packet的一些工具。比如PacketDecoder或者PacketEncoder这种编码解码工具、Json序列化的工具等等。\n\n重点说下Packet包\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923992993-0a7ce29c-e754-48ef-bf3c-ef7b1fae200b.png?x-oss-process=image%2Fresize%2Cw_1500)\n\ndata数据、nsp命名空间、ackId唯一标识，可能用于消息确认等其他用途、type、subType都是包的类型\n\n包的类型又分为下面这些\n\n\n\n***#PacketType.java***\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924404084-776ee465-968b-4e16-ab5c-0cd87dc67832.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n类型Connect、Disconnect或者是Event或者是Ackd等等\n\n\n\n回到上图这个attachments我也没明白，应该是可以自定义的一些字段，附件，方便扩展。同时还需要进行初始化\n\n***#Packet.java***\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924500498-1170a570-9d64-40cc-89fe-535e6b8bc16c.png)\n\n\n\nPacket包里面的数据就是data，data经过***#PacketEncoder***编码后就变了ByteBuf，Netty就可以在Channel中传输了，下图是编码的过程\n\n***#PacketEncoder.java***\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/2597675/1614925102874-bfc4aba2-6291-45c2-b661-6c9f2ac75d16.png?x-oss-process=image%2Fresize%2Cw_1500)\n\n\n\n#### Listener\n\n.... 未完待续\n\n#####  ","slug":"socket-io服务端理解和组件分析","published":1,"updated":"2021-03-10T14:16:29.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm4slzph00073enp8wip3icq","content":"<h2 id=\"回顾Socket\"><a href=\"#回顾Socket\" class=\"headerlink\" title=\"回顾Socket\"></a>回顾Socket</h2><p>Socket建立请求和处理数据的过程</p>\n<h3 id=\"一个客户端\"><a href=\"#一个客户端\" class=\"headerlink\" title=\"一个客户端\"></a>一个客户端</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838003875-4ba0c7b8-51cb-448c-a826-f73ada176fa9.png\" alt=\"image.png\"></p>\n<p>整个过程服务端都是一个线程在做，客户端发来请求，服务端accpet()接受请求，read(), write()处理数据， 处理完数据关闭连接、释放线程。</p>\n<h3 id=\"多个客户端\"><a href=\"#多个客户端\" class=\"headerlink\" title=\"多个客户端\"></a>多个客户端</h3><p>如果多个客户端怎么办？</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838158237-31c32765-eaa7-462b-b864-7b21a0a0e90a.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>那就每一个客户端创建一个线程。新建一个线程专门用来监听，有新客户端就new一个新的线程。</p>\n<p>我们还可以优化一下，<strong>池化思想</strong>。将new Thread这个过程变成， 从pool线程池里面获取，让很多线程不随着连接关闭，多次复用。</p>\n<p>这就出现了NIO优化的地方</p>\n<h3 id=\"NIO非阻塞思想\"><a href=\"#NIO非阻塞思想\" class=\"headerlink\" title=\"NIO非阻塞思想\"></a>NIO非阻塞思想</h3><p>NIO 三个关键组件  Selector、Buffer、Channel</p>\n<p>Selector有点像我们上面图的监听线程，他的作用就是从线程池里面找到空闲的线程来处理客户端的请求。</p>\n<p>Selector充当中间分配任务的角色，所有客户端线程、服务端线程都注册到我这，我帮你们进行分配，进行多路复用。</p>\n<p>线程池里面的线程会轮询去Selector中找感兴趣的事，不会绑定某个连接上，read()、write()事件处理完就继续找下一个连接要处理的事情，等到上一个连接有新的数据再返回处理。</p>\n<p>Channel、Buffer改变传统流的方式，能够更好管理数据，提高效率。</p>\n<h2 id=\"Netty基础概念和代码\"><a href=\"#Netty基础概念和代码\" class=\"headerlink\" title=\"Netty基础概念和代码\"></a>Netty基础概念和代码</h2><p>Netty就是对NIO的使用进行了简化，又优化了很多地方。但是核心思想还是不变的，还是采用Channel和Buffer这种结构。</p>\n<p>Netty将Channel中加入ChannelHandler这种组件，它负责调度应用程序的处理逻辑，并驱动数据和事件经过网络层。简单来说就是加入了带有方向的拦截器，用来处理数据。</p>\n<p>Buffer也变成了ByteBuf。</p>\n<p>为了简化nio使用，Netty使用了<strong>BootStrap启动器</strong>用来辅助进行建立<strong>socket连接</strong>、<strong>创建Channel通道</strong>等等这些操作，设计模式用的是构建者模式。</p>\n<p>同时还有<strong>EventLoop</strong>用来管理所有的Channel，这里的<strong>EventLoop</strong>可以理解为上面图的<strong>监控线程</strong>、或者是<strong>工作线程</strong>这种线程。EventLoopGroup就是线程池，所以我们的工作线程要有线程池，这就是Netty代码里面的 NioEventLoopGroup <strong>work</strong> = new NioEventLoopGroup(); 同样，如果监控线程如果监控的是一个端口可以只用一个线程、如果是多个端口那就要用线程池了。所以在Netty中就出现了boss这种线程池（NioEventLoopGroup <strong>boss</strong> = new NioEventLoopGroup(); ）</p>\n<p>Netty的学习首先要搞清楚它的架构、设计模式。</p>\n<p>清楚他的各个组件的作用和关系，如图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614835289260-6477f02f-b166-43dc-9370-441899d5f036.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>如果你认为 ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的 Channel- Handler 实例链，是ChannelHandler的容器。</p>\n<p>Netty在Channel里传输的数据是ByteBuf，所以我们要将客户端和服务端所接受的数据都转化为ByteBuf，这就涉及到了一个Netty的重要部分，编码和解码。</p>\n<p>还有就是ChannelHandlerContext，是ChannelHandler上下文内容，ChannelHandler处理完的数据都是ChannelHandlerContext来传输下一个ChannelHandler。ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关 联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandler- Context。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在 同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p>\n<p>使用Netty大致的过程就是：</p>\n<ol>\n<li>创建Bootstrap启动器</li>\n<li>创建监控线程组boss和工作线程组work。（客户端不用boss)</li>\n<li>用Bootstrap建立Channel，添加ChannelHanlder拦截器</li>\n<li>客户端用Bootstrap连接服务端。服务端用Bootstrap绑定端口开启监听</li>\n</ol>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NettyServer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ServerBootstrap bootstrap &#x3D; new ServerBootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">        NioEventLoopGroup work &#x3D; new NioEventLoopGroup();</span><br><span class=\"line\">        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();</span><br><span class=\"line\"></span><br><span class=\"line\">        bootstrap.group(boss, work)</span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(new DecoderHandler());</span><br><span class=\"line\">                        ch.pipeline().addLast(new ServerInHandler());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        ChannelFuture future &#x3D; bootstrap.bind(1000).addListener((listener) -&gt; &#123;</span><br><span class=\"line\">            if (listener.isSuccess()) &#123;</span><br><span class=\"line\">                System.out.println(&quot;服务器启动成功&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># NettyClient.java</span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Netty客户端</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class NettyClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoopGroup work;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean connect(String inetHost, Integer inetPort) throws InterruptedException &#123;</span><br><span class=\"line\">        work &#x3D; new NioEventLoopGroup();</span><br><span class=\"line\">        bootstrap.group(work)</span><br><span class=\"line\">                .channel(NioSocketChannel.class) &#x2F;&#x2F;</span><br><span class=\"line\">                .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(new EncoderHandler());</span><br><span class=\"line\">                        ch.pipeline().addLast(new ClientInHandler());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            bootstrap.connect(inetHost, inetPort).addListener((listener) -&gt; &#123;</span><br><span class=\"line\">                if (listener.isSuccess()) &#123;</span><br><span class=\"line\">                    System.out.println(&quot;连接成功&quot;);</span><br><span class=\"line\">                    ChannelFuture future &#x3D; (ChannelFuture) listener;</span><br><span class=\"line\">                    startConsoleThread(future.channel());  &#x2F;&#x2F; 开启控制台线程</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"socketio实例分析\"><a href=\"#socketio实例分析\" class=\"headerlink\" title=\"socketio实例分析\"></a>socketio实例分析</h2><p>分析的是github上socketio这个项目 <a href=\"https://github.com/mrniko/netty-socketio/\">https://github.com/mrniko/netty-socketio/</a></p>\n<p>Socket.IO server implemented on Java. Realtime java framework</p>\n<p>用netty实现的实时网络通信</p>\n<h3 id=\"模块分析\"><a href=\"#模块分析\" class=\"headerlink\" title=\"模块分析\"></a>模块分析</h3><h4 id=\"Namespace\"><a href=\"#Namespace\" class=\"headerlink\" title=\"Namespace\"></a>Namespace</h4><p>在一个命名空间空间的所有客户端都是共享的</p>\n<p>那共享的都有什么呢？一个一个分析</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614920618711-1ada87d2-c22c-424a-a609-0c98624dbbfa.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>先看ScannerEngine类内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ScannerEngine.class</span><br><span class=\"line\">    </span><br><span class=\"line\">public void scan(Namespace namespace, Object object, Class&lt;?&gt; clazz)</span><br><span class=\"line\">            throws IllegalArgumentException &#123;</span><br><span class=\"line\">        Method[] methods &#x3D; clazz.getDeclaredMethods();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 类不是Object类型的</span><br><span class=\"line\">        if (!clazz.isAssignableFrom(object.getClass())) &#123;</span><br><span class=\"line\">            for (Method method : methods) &#123;</span><br><span class=\"line\">                for (AnnotationScanner annotationScanner : annotations) &#123;</span><br><span class=\"line\">                    Annotation ann &#x3D; method.getAnnotation(annotationScanner.getScanAnnotation());</span><br><span class=\"line\">                    if (ann !&#x3D; null) &#123;</span><br><span class=\"line\">                        annotationScanner.validate(method, clazz);</span><br><span class=\"line\"></span><br><span class=\"line\">                        Method m &#x3D; findSimilarMethod(object.getClass(), method);</span><br><span class=\"line\">                        if (m !&#x3D; null) &#123;</span><br><span class=\"line\">                            annotationScanner.addListener(namespace, object, m, ann);</span><br><span class=\"line\">                        &#125; else &#123;</span><br><span class=\"line\">                            log.warn(&quot;Method similar to &quot; + method.getName() + &quot; can&#39;t be found in &quot; + object.getClass());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F; -----------------主要看这段--------------------------</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            for (Method method : methods) &#123;</span><br><span class=\"line\">                for (AnnotationScanner annotationScanner : annotations) &#123;</span><br><span class=\"line\">                    Annotation ann &#x3D; method.getAnnotation(annotationScanner.getScanAnnotation());</span><br><span class=\"line\">                    if (ann !&#x3D; null) &#123;</span><br><span class=\"line\">                        annotationScanner.validate(method, clazz);</span><br><span class=\"line\">                        makeAccessible(method);</span><br><span class=\"line\">                        annotationScanner.addListener(namespace, object, method, ann);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#x2F;&#x2F; -----------------end--------------------------</span><br><span class=\"line\">            if (clazz.getSuperclass() !&#x3D; null) &#123;</span><br><span class=\"line\">                scan(namespace, object, clazz.getSuperclass());</span><br><span class=\"line\">            &#125; else if (clazz.isInterface()) &#123;</span><br><span class=\"line\">                for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) &#123;</span><br><span class=\"line\">                    scan(namespace, object, superIfc);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>先说这段代码干嘛的，去扫描类里面的方法，有没有带有这三个注解的方法，如果有的话，把相应的下图三个监听器添加到相应命名空间下的执行队列中。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921713851-7997ddad-d955-4573-b8d9-0967228615f4.png\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921813582-a02626b3-2473-42f9-832a-0424577f9a92.png\" alt=\"image.png\"></p>\n<p>所以ScannerEngine类就是扫描注解，然后添加监听器。加个上面三个注解的方法都会添加到监听器中。</p>\n<p>NameSpace这个对象拿着ScannerEngine引擎去查找带注解的方法，并添加到NameSpace中。</p>\n<p>eventListeners、connectListeners、disconnectListeners</p>\n<p>这三个就不要特别说明了，是三个不同类别的监听器，分别在不同时期进行执行。</p>\n<p>pingListeners也是同理</p>\n<p>allClients是在这个命名空间下所有的客户端， SocketIOClient是客户端实体</p>\n<p>roomClients是房间内的客户端，就算是分组把</p>\n<p>clientRooms是房间，也就是组。可以移除客户端也可以添加。</p>\n<h4 id=\"NameSpaceHub\"><a href=\"#NameSpaceHub\" class=\"headerlink\" title=\"NameSpaceHub\"></a>NameSpaceHub</h4><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923575816-c1e9f0ca-b3e7-4941-84c3-85bbe741e7c1.png\" alt=\"image.png\"></p>\n<p>用来操作NameSpaceHub的，主要是创建、获取移除等等，同时可以看到所有的NameSpace。</p>\n<h4 id=\"Protocol\"><a href=\"#Protocol\" class=\"headerlink\" title=\"Protocol\"></a>Protocol</h4><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923846574-f407d315-a478-4bcf-878d-5cbf561b1fb3.png\" alt=\"image.png\"></p>\n<p>因为在使用Netty过程中我们要自定义协议格式，这里Packet就是数据协议包，AuthPacket是一个认证的协议包。</p>\n<p>剩下都是围绕Packet的一些工具。比如PacketDecoder或者PacketEncoder这种编码解码工具、Json序列化的工具等等。</p>\n<p>重点说下Packet包</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923992993-0a7ce29c-e754-48ef-bf3c-ef7b1fae200b.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>data数据、nsp命名空间、ackId唯一标识，可能用于消息确认等其他用途、type、subType都是包的类型</p>\n<p>包的类型又分为下面这些</p>\n<p><em><strong>#PacketType.java</strong></em></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924404084-776ee465-968b-4e16-ab5c-0cd87dc67832.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>类型Connect、Disconnect或者是Event或者是Ackd等等</p>\n<p>回到上图这个attachments我也没明白，应该是可以自定义的一些字段，附件，方便扩展。同时还需要进行初始化</p>\n<p><em><strong>#Packet.java</strong></em></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924500498-1170a570-9d64-40cc-89fe-535e6b8bc16c.png\" alt=\"image.png\"></p>\n<p>Packet包里面的数据就是data，data经过***#PacketEncoder***编码后就变了ByteBuf，Netty就可以在Channel中传输了，下图是编码的过程</p>\n<p><em><strong>#PacketEncoder.java</strong></em></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614925102874-bfc4aba2-6291-45c2-b661-6c9f2ac75d16.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<h4 id=\"Listener\"><a href=\"#Listener\" class=\"headerlink\" title=\"Listener\"></a>Listener</h4><p>…. 未完待续</p>\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"回顾Socket\"><a href=\"#回顾Socket\" class=\"headerlink\" title=\"回顾Socket\"></a>回顾Socket</h2><p>Socket建立请求和处理数据的过程</p>\n<h3 id=\"一个客户端\"><a href=\"#一个客户端\" class=\"headerlink\" title=\"一个客户端\"></a>一个客户端</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838003875-4ba0c7b8-51cb-448c-a826-f73ada176fa9.png\" alt=\"image.png\"></p>\n<p>整个过程服务端都是一个线程在做，客户端发来请求，服务端accpet()接受请求，read(), write()处理数据， 处理完数据关闭连接、释放线程。</p>\n<h3 id=\"多个客户端\"><a href=\"#多个客户端\" class=\"headerlink\" title=\"多个客户端\"></a>多个客户端</h3><p>如果多个客户端怎么办？</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838158237-31c32765-eaa7-462b-b864-7b21a0a0e90a.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>那就每一个客户端创建一个线程。新建一个线程专门用来监听，有新客户端就new一个新的线程。</p>\n<p>我们还可以优化一下，<strong>池化思想</strong>。将new Thread这个过程变成， 从pool线程池里面获取，让很多线程不随着连接关闭，多次复用。</p>\n<p>这就出现了NIO优化的地方</p>\n<h3 id=\"NIO非阻塞思想\"><a href=\"#NIO非阻塞思想\" class=\"headerlink\" title=\"NIO非阻塞思想\"></a>NIO非阻塞思想</h3><p>NIO 三个关键组件  Selector、Buffer、Channel</p>\n<p>Selector有点像我们上面图的监听线程，他的作用就是从线程池里面找到空闲的线程来处理客户端的请求。</p>\n<p>Selector充当中间分配任务的角色，所有客户端线程、服务端线程都注册到我这，我帮你们进行分配，进行多路复用。</p>\n<p>线程池里面的线程会轮询去Selector中找感兴趣的事，不会绑定某个连接上，read()、write()事件处理完就继续找下一个连接要处理的事情，等到上一个连接有新的数据再返回处理。</p>\n<p>Channel、Buffer改变传统流的方式，能够更好管理数据，提高效率。</p>\n<h2 id=\"Netty基础概念和代码\"><a href=\"#Netty基础概念和代码\" class=\"headerlink\" title=\"Netty基础概念和代码\"></a>Netty基础概念和代码</h2><p>Netty就是对NIO的使用进行了简化，又优化了很多地方。但是核心思想还是不变的，还是采用Channel和Buffer这种结构。</p>\n<p>Netty将Channel中加入ChannelHandler这种组件，它负责调度应用程序的处理逻辑，并驱动数据和事件经过网络层。简单来说就是加入了带有方向的拦截器，用来处理数据。</p>\n<p>Buffer也变成了ByteBuf。</p>\n<p>为了简化nio使用，Netty使用了<strong>BootStrap启动器</strong>用来辅助进行建立<strong>socket连接</strong>、<strong>创建Channel通道</strong>等等这些操作，设计模式用的是构建者模式。</p>\n<p>同时还有<strong>EventLoop</strong>用来管理所有的Channel，这里的<strong>EventLoop</strong>可以理解为上面图的<strong>监控线程</strong>、或者是<strong>工作线程</strong>这种线程。EventLoopGroup就是线程池，所以我们的工作线程要有线程池，这就是Netty代码里面的 NioEventLoopGroup <strong>work</strong> = new NioEventLoopGroup(); 同样，如果监控线程如果监控的是一个端口可以只用一个线程、如果是多个端口那就要用线程池了。所以在Netty中就出现了boss这种线程池（NioEventLoopGroup <strong>boss</strong> = new NioEventLoopGroup(); ）</p>\n<p>Netty的学习首先要搞清楚它的架构、设计模式。</p>\n<p>清楚他的各个组件的作用和关系，如图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614835289260-6477f02f-b166-43dc-9370-441899d5f036.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>如果你认为 ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的 Channel- Handler 实例链，是ChannelHandler的容器。</p>\n<p>Netty在Channel里传输的数据是ByteBuf，所以我们要将客户端和服务端所接受的数据都转化为ByteBuf，这就涉及到了一个Netty的重要部分，编码和解码。</p>\n<p>还有就是ChannelHandlerContext，是ChannelHandler上下文内容，ChannelHandler处理完的数据都是ChannelHandlerContext来传输下一个ChannelHandler。ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关 联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandler- Context。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在 同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p>\n<p>使用Netty大致的过程就是：</p>\n<ol>\n<li>创建Bootstrap启动器</li>\n<li>创建监控线程组boss和工作线程组work。（客户端不用boss)</li>\n<li>用Bootstrap建立Channel，添加ChannelHanlder拦截器</li>\n<li>客户端用Bootstrap连接服务端。服务端用Bootstrap绑定端口开启监听</li>\n</ol>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class NettyServer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ServerBootstrap bootstrap &#x3D; new ServerBootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">        NioEventLoopGroup work &#x3D; new NioEventLoopGroup();</span><br><span class=\"line\">        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();</span><br><span class=\"line\"></span><br><span class=\"line\">        bootstrap.group(boss, work)</span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(new DecoderHandler());</span><br><span class=\"line\">                        ch.pipeline().addLast(new ServerInHandler());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        ChannelFuture future &#x3D; bootstrap.bind(1000).addListener((listener) -&gt; &#123;</span><br><span class=\"line\">            if (listener.isSuccess()) &#123;</span><br><span class=\"line\">                System.out.println(&quot;服务器启动成功&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># NettyClient.java</span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Netty客户端</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class NettyClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">    EventLoopGroup work;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean connect(String inetHost, Integer inetPort) throws InterruptedException &#123;</span><br><span class=\"line\">        work &#x3D; new NioEventLoopGroup();</span><br><span class=\"line\">        bootstrap.group(work)</span><br><span class=\"line\">                .channel(NioSocketChannel.class) &#x2F;&#x2F;</span><br><span class=\"line\">                .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(new EncoderHandler());</span><br><span class=\"line\">                        ch.pipeline().addLast(new ClientInHandler());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            bootstrap.connect(inetHost, inetPort).addListener((listener) -&gt; &#123;</span><br><span class=\"line\">                if (listener.isSuccess()) &#123;</span><br><span class=\"line\">                    System.out.println(&quot;连接成功&quot;);</span><br><span class=\"line\">                    ChannelFuture future &#x3D; (ChannelFuture) listener;</span><br><span class=\"line\">                    startConsoleThread(future.channel());  &#x2F;&#x2F; 开启控制台线程</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"socketio实例分析\"><a href=\"#socketio实例分析\" class=\"headerlink\" title=\"socketio实例分析\"></a>socketio实例分析</h2><p>分析的是github上socketio这个项目 <a href=\"https://github.com/mrniko/netty-socketio/\">https://github.com/mrniko/netty-socketio/</a></p>\n<p>Socket.IO server implemented on Java. Realtime java framework</p>\n<p>用netty实现的实时网络通信</p>\n<h3 id=\"模块分析\"><a href=\"#模块分析\" class=\"headerlink\" title=\"模块分析\"></a>模块分析</h3><h4 id=\"Namespace\"><a href=\"#Namespace\" class=\"headerlink\" title=\"Namespace\"></a>Namespace</h4><p>在一个命名空间空间的所有客户端都是共享的</p>\n<p>那共享的都有什么呢？一个一个分析</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614920618711-1ada87d2-c22c-424a-a609-0c98624dbbfa.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>先看ScannerEngine类内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ScannerEngine.class</span><br><span class=\"line\">    </span><br><span class=\"line\">public void scan(Namespace namespace, Object object, Class&lt;?&gt; clazz)</span><br><span class=\"line\">            throws IllegalArgumentException &#123;</span><br><span class=\"line\">        Method[] methods &#x3D; clazz.getDeclaredMethods();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 类不是Object类型的</span><br><span class=\"line\">        if (!clazz.isAssignableFrom(object.getClass())) &#123;</span><br><span class=\"line\">            for (Method method : methods) &#123;</span><br><span class=\"line\">                for (AnnotationScanner annotationScanner : annotations) &#123;</span><br><span class=\"line\">                    Annotation ann &#x3D; method.getAnnotation(annotationScanner.getScanAnnotation());</span><br><span class=\"line\">                    if (ann !&#x3D; null) &#123;</span><br><span class=\"line\">                        annotationScanner.validate(method, clazz);</span><br><span class=\"line\"></span><br><span class=\"line\">                        Method m &#x3D; findSimilarMethod(object.getClass(), method);</span><br><span class=\"line\">                        if (m !&#x3D; null) &#123;</span><br><span class=\"line\">                            annotationScanner.addListener(namespace, object, m, ann);</span><br><span class=\"line\">                        &#125; else &#123;</span><br><span class=\"line\">                            log.warn(&quot;Method similar to &quot; + method.getName() + &quot; can&#39;t be found in &quot; + object.getClass());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F; -----------------主要看这段--------------------------</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            for (Method method : methods) &#123;</span><br><span class=\"line\">                for (AnnotationScanner annotationScanner : annotations) &#123;</span><br><span class=\"line\">                    Annotation ann &#x3D; method.getAnnotation(annotationScanner.getScanAnnotation());</span><br><span class=\"line\">                    if (ann !&#x3D; null) &#123;</span><br><span class=\"line\">                        annotationScanner.validate(method, clazz);</span><br><span class=\"line\">                        makeAccessible(method);</span><br><span class=\"line\">                        annotationScanner.addListener(namespace, object, method, ann);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#x2F;&#x2F; -----------------end--------------------------</span><br><span class=\"line\">            if (clazz.getSuperclass() !&#x3D; null) &#123;</span><br><span class=\"line\">                scan(namespace, object, clazz.getSuperclass());</span><br><span class=\"line\">            &#125; else if (clazz.isInterface()) &#123;</span><br><span class=\"line\">                for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) &#123;</span><br><span class=\"line\">                    scan(namespace, object, superIfc);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>先说这段代码干嘛的，去扫描类里面的方法，有没有带有这三个注解的方法，如果有的话，把相应的下图三个监听器添加到相应命名空间下的执行队列中。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921713851-7997ddad-d955-4573-b8d9-0967228615f4.png\" alt=\"image.png\"><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921813582-a02626b3-2473-42f9-832a-0424577f9a92.png\" alt=\"image.png\"></p>\n<p>所以ScannerEngine类就是扫描注解，然后添加监听器。加个上面三个注解的方法都会添加到监听器中。</p>\n<p>NameSpace这个对象拿着ScannerEngine引擎去查找带注解的方法，并添加到NameSpace中。</p>\n<p>eventListeners、connectListeners、disconnectListeners</p>\n<p>这三个就不要特别说明了，是三个不同类别的监听器，分别在不同时期进行执行。</p>\n<p>pingListeners也是同理</p>\n<p>allClients是在这个命名空间下所有的客户端， SocketIOClient是客户端实体</p>\n<p>roomClients是房间内的客户端，就算是分组把</p>\n<p>clientRooms是房间，也就是组。可以移除客户端也可以添加。</p>\n<h4 id=\"NameSpaceHub\"><a href=\"#NameSpaceHub\" class=\"headerlink\" title=\"NameSpaceHub\"></a>NameSpaceHub</h4><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923575816-c1e9f0ca-b3e7-4941-84c3-85bbe741e7c1.png\" alt=\"image.png\"></p>\n<p>用来操作NameSpaceHub的，主要是创建、获取移除等等，同时可以看到所有的NameSpace。</p>\n<h4 id=\"Protocol\"><a href=\"#Protocol\" class=\"headerlink\" title=\"Protocol\"></a>Protocol</h4><p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923846574-f407d315-a478-4bcf-878d-5cbf561b1fb3.png\" alt=\"image.png\"></p>\n<p>因为在使用Netty过程中我们要自定义协议格式，这里Packet就是数据协议包，AuthPacket是一个认证的协议包。</p>\n<p>剩下都是围绕Packet的一些工具。比如PacketDecoder或者PacketEncoder这种编码解码工具、Json序列化的工具等等。</p>\n<p>重点说下Packet包</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923992993-0a7ce29c-e754-48ef-bf3c-ef7b1fae200b.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>data数据、nsp命名空间、ackId唯一标识，可能用于消息确认等其他用途、type、subType都是包的类型</p>\n<p>包的类型又分为下面这些</p>\n<p><em><strong>#PacketType.java</strong></em></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924404084-776ee465-968b-4e16-ab5c-0cd87dc67832.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<p>类型Connect、Disconnect或者是Event或者是Ackd等等</p>\n<p>回到上图这个attachments我也没明白，应该是可以自定义的一些字段，附件，方便扩展。同时还需要进行初始化</p>\n<p><em><strong>#Packet.java</strong></em></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924500498-1170a570-9d64-40cc-89fe-535e6b8bc16c.png\" alt=\"image.png\"></p>\n<p>Packet包里面的数据就是data，data经过***#PacketEncoder***编码后就变了ByteBuf，Netty就可以在Channel中传输了，下图是编码的过程</p>\n<p><em><strong>#PacketEncoder.java</strong></em></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/2597675/1614925102874-bfc4aba2-6291-45c2-b661-6c9f2ac75d16.png?x-oss-process=image/resize,w_1500\" alt=\"image.png\"></p>\n<h4 id=\"Listener\"><a href=\"#Listener\" class=\"headerlink\" title=\"Listener\"></a>Listener</h4><p>…. 未完待续</p>\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckm4slzpa00013enp8kyahcaz","tag_id":"ckm4slzpf00043enpepo56r9w","_id":"ckm4slzpj00093enpcrb0651t"},{"post_id":"ckm4slzpd00033enp5shzhww4","tag_id":"ckm4slzpi00083enp2p9177we","_id":"ckm4slzpj000b3enp7yd796e5"},{"post_id":"ckm4slzpg00063enp7poc5yff","tag_id":"ckm4slzpj000a3enpblec1fln","_id":"ckm4slzpk000d3enp785wap33"},{"post_id":"ckm4slzph00073enp8wip3icq","tag_id":"ckm4slzpj000c3enp13kjhg0a","_id":"ckm4slzpk000e3enp7ndd2v82"}],"Tag":[{"name":"Kafka","_id":"ckm4slzpf00043enpepo56r9w"},{"name":"WebSocket","_id":"ckm4slzpi00083enp2p9177we"},{"name":"Mysql","_id":"ckm4slzpj000a3enpblec1fln"},{"name":"Netty Socket.io","_id":"ckm4slzpj000c3enp13kjhg0a"}]}}