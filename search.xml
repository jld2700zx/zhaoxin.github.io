<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebSocket服务端实现</title>
      <link href="2021/08/10/WebSocket%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2021/08/10/WebSocket%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket服务端实现"><a href="#WebSocket服务端实现" class="headerlink" title="WebSocket服务端实现"></a>WebSocket服务端实现</h1><h2 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h2><p>当客户端通过一系列的配置字段（主机（host）、端口（port）、资源名称（resource name）和安全标记（secure））以及一个可被使用的协议（protocol）和扩展（extensions）列表来建立一个WebSocket连接</p><h2 id="2-关闭WebSocket连接"><a href="#2-关闭WebSocket连接" class="headerlink" title="2. 关闭WebSocket连接"></a>2. 关闭WebSocket连接</h2><h3 id="关闭原理"><a href="#关闭原理" class="headerlink" title="关闭原理"></a>关闭原理</h3><p>关闭tcp连接和tls会话。 tcp关闭才算<em><strong>彻底</strong></em></p><p>用一个状态码 <code>code</code> （第 7.4 节）和一个可选的关闭原因 <code>reason</code> （第 7.1.6 节）来<code>开始 WebSocket 关闭握手</code>，</p><p><code>WebSocket 关闭状态码</code>被默认为1005。</p><h3 id="服务端如何关闭"><a href="#服务端如何关闭" class="headerlink" title="服务端如何关闭"></a>服务端如何关闭</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613888491004-b3205912-ae69-4bb2-82c2-9410fdb212b5.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>如何管理所有的session </p><p>通过map</p><h2 id="3-WebSocket-代码实现"><a href="#3-WebSocket-代码实现" class="headerlink" title="3. WebSocket 代码实现"></a>3. WebSocket 代码实现</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig&#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    @Bean</span><br><span class="line">    public ReverseWebSocketEndpoint reverseWebSocketEndpoint() &#123;</span><br><span class="line">        return new ReverseWebSocketEndpoint();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Bean</span><br><span class="line">    public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class="line">        return new ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端建立WebSocket连接测试"><a href="#客户端建立WebSocket连接测试" class="headerlink" title="客户端建立WebSocket连接测试"></a>客户端建立WebSocket连接测试</h2><p>前端建立WebSocket连接</p><p>在浏览器控制台输入下面标红的语法即可</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885589624-6db65e08-8609-4ab2-9353-661849c64ef1.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>⚠️：同源问题</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885652515-f90275c9-0050-46ec-84c3-a977abfc7101.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><strong>ServerEndpointExporter类代码分析</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613891579226-535abd17-59a1-467f-9828-dbfa87e0d87b.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>annotatedEndpointClasses是记录带有@<em>ServerEndpoint的类的一个集合</em></p><p>这里涉及到<strong>InitializingBean</strong>接口、<strong>WebApplicationObjectSupport</strong>类的使用</p><p><strong>WebApplicationObjectSupport类，</strong>继承此类可以获取ApplicationContext对象，调用getWebApplicationContext()获取WebApplicationContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注：spring在代码中获取bean的几种办法</span><br><span class="line">方法一：在初始化时保存ApplicationContext对象 </span><br><span class="line">方法二：通过Spring提供的utils类获取ApplicationContext对象 </span><br><span class="line">方法三：继承自抽象类ApplicationObjectSupport </span><br><span class="line">方法四：继承自抽象类WebApplicationObjectSupport </span><br><span class="line">方法五：实现接口ApplicationContextAware </span><br><span class="line">方法六：通过Spring提供的ContextLoader</span><br></pre></td></tr></table></figure><p>注：spring在代码中获取bean的几种办法</p><p>方法一：在初始化时保存ApplicationContext对象 方法二：通过Spring提供的utils类获取ApplicationContext对象 方法三：继承自抽象类ApplicationObjectSupport 方法四：继承自抽象类WebApplicationObjectSupport 方法五：实现接口ApplicationContextAware 方法六：通过Spring提供的ContextLoader</p><p><strong>InitializingBean</strong>接口为bean提供了初始化方法的方式，它只包括<strong>afterPropertiesSet方法</strong>，凡是继承该接口的类，在初始化bean的时候会执行该方法。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613895411231-35c1eeab-3b5d-458d-bbdf-0b629cc699c3.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>工具</p><p><a href="http://coolaf.com/tool/chattest">http://coolaf.com/tool/chattest</a> 在线websocket</p><p>参考：</p><p><a href="https://www.cnblogs.com/kiwifly/p/11729304.html">https://www.cnblogs.com/kiwifly/p/11729304.html</a>  session共享问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jedis线程回收问题</title>
      <link href="2021/01/10/Jedis%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/01/10/Jedis%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问题：redis.clients.jedis.exceptions.JedisConnectionException:Could not get a resource from the pool</p></blockquote><p>查询问题原因，猜测以下几点</p><ol><li>Redis没启动</li><li>资源池参数不合理：比如QPS高，连接池小。</li><li>因为用的Jedis, jedis线程池用完了没有归还</li></ol><p>进入redis客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> info client</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Client</span></span><br><span class="line">connected_clients:628</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br></pre></td></tr></table></figure><p>查过几次连接数居高不变</p><p>config get maxclients</p><p>查询出来也没问题</p><p>然后继续查询Jedis回收问题</p><p>网上多数都说没有finnally回收</p><p>但是项目代码是有的</p><p>然后开始Debug，发现确实没有走到那步。</p><p>然后找原因发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">    jedis.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。。</p><p>这不应该是jedis.close啊，应该是jedisPool.close()啊，粗心了。</p><p>正好在这总结下jedis.close 和 jedisPool.close的区别</p><p>在jedis3.0后，jedisPool.returnResource()方法是被弃用的</p><p>….未完待续</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>socket.io服务端理解和组件分析</title>
      <link href="2020/12/10/socket-io%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%90%86%E8%A7%A3%E5%92%8C%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>2020/12/10/socket-io%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%90%86%E8%A7%A3%E5%92%8C%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾Socket"><a href="#回顾Socket" class="headerlink" title="回顾Socket"></a>回顾Socket</h2><p>Socket建立请求和处理数据的过程</p><h3 id="一个客户端"><a href="#一个客户端" class="headerlink" title="一个客户端"></a>一个客户端</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838003875-4ba0c7b8-51cb-448c-a826-f73ada176fa9.png" alt="image.png"></p><p>整个过程服务端都是一个线程在做，客户端发来请求，服务端accpet()接受请求，read(), write()处理数据， 处理完数据关闭连接、释放线程。</p><h3 id="多个客户端"><a href="#多个客户端" class="headerlink" title="多个客户端"></a>多个客户端</h3><p>如果多个客户端怎么办？</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838158237-31c32765-eaa7-462b-b864-7b21a0a0e90a.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>那就每一个客户端创建一个线程。新建一个线程专门用来监听，有新客户端就new一个新的线程。</p><p>我们还可以优化一下，<strong>池化思想</strong>。将new Thread这个过程变成， 从pool线程池里面获取，让很多线程不随着连接关闭，多次复用。</p><p>这就出现了NIO优化的地方</p><h3 id="NIO非阻塞思想"><a href="#NIO非阻塞思想" class="headerlink" title="NIO非阻塞思想"></a>NIO非阻塞思想</h3><p>NIO 三个关键组件  Selector、Buffer、Channel</p><p>Selector有点像我们上面图的监听线程，他的作用就是从线程池里面找到空闲的线程来处理客户端的请求。</p><p>Selector充当中间分配任务的角色，所有客户端线程、服务端线程都注册到我这，我帮你们进行分配，进行多路复用。</p><p>线程池里面的线程会轮询去Selector中找感兴趣的事，不会绑定某个连接上，read()、write()事件处理完就继续找下一个连接要处理的事情，等到上一个连接有新的数据再返回处理。</p><p>Channel、Buffer改变传统流的方式，能够更好管理数据，提高效率。</p><h2 id="Netty基础概念和代码"><a href="#Netty基础概念和代码" class="headerlink" title="Netty基础概念和代码"></a>Netty基础概念和代码</h2><p>Netty就是对NIO的使用进行了简化，又优化了很多地方。但是核心思想还是不变的，还是采用Channel和Buffer这种结构。</p><p>Netty将Channel中加入ChannelHandler这种组件，它负责调度应用程序的处理逻辑，并驱动数据和事件经过网络层。简单来说就是加入了带有方向的拦截器，用来处理数据。</p><p>Buffer也变成了ByteBuf。</p><p>为了简化nio使用，Netty使用了<strong>BootStrap启动器</strong>用来辅助进行建立<strong>socket连接</strong>、<strong>创建Channel通道</strong>等等这些操作，设计模式用的是构建者模式。</p><p>同时还有<strong>EventLoop</strong>用来管理所有的Channel，这里的<strong>EventLoop</strong>可以理解为上面图的<strong>监控线程</strong>、或者是<strong>工作线程</strong>这种线程。EventLoopGroup就是线程池，所以我们的工作线程要有线程池，这就是Netty代码里面的 NioEventLoopGroup <strong>work</strong> = new NioEventLoopGroup(); 同样，如果监控线程如果监控的是一个端口可以只用一个线程、如果是多个端口那就要用线程池了。所以在Netty中就出现了boss这种线程池（NioEventLoopGroup <strong>boss</strong> = new NioEventLoopGroup(); ）</p><p>Netty的学习首先要搞清楚它的架构、设计模式。</p><p>清楚他的各个组件的作用和关系，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614835289260-6477f02f-b166-43dc-9370-441899d5f036.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>如果你认为 ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的 Channel- Handler 实例链，是ChannelHandler的容器。</p><p>Netty在Channel里传输的数据是ByteBuf，所以我们要将客户端和服务端所接受的数据都转化为ByteBuf，这就涉及到了一个Netty的重要部分，编码和解码。</p><p>还有就是ChannelHandlerContext，是ChannelHandler上下文内容，ChannelHandler处理完的数据都是ChannelHandlerContext来传输下一个ChannelHandler。ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关 联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandler- Context。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在 同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p><p>使用Netty大致的过程就是：</p><ol><li>创建Bootstrap启动器</li><li>创建监控线程组boss和工作线程组work。（客户端不用boss)</li><li>用Bootstrap建立Channel，添加ChannelHanlder拦截器</li><li>客户端用Bootstrap连接服务端。服务端用Bootstrap绑定端口开启监听</li></ol><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ServerBootstrap bootstrap &#x3D; new ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup work &#x3D; new NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(boss, work)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(new DecoderHandler());</span><br><span class="line">                        ch.pipeline().addLast(new ServerInHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        ChannelFuture future &#x3D; bootstrap.bind(1000).addListener((listener) -&gt; &#123;</span><br><span class="line">            if (listener.isSuccess()) &#123;</span><br><span class="line">                System.out.println(&quot;服务器启动成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># NettyClient.java</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Netty客户端</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class NettyClient &#123;</span><br><span class="line"></span><br><span class="line">    Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class="line"></span><br><span class="line">    EventLoopGroup work;</span><br><span class="line"></span><br><span class="line">    public boolean connect(String inetHost, Integer inetPort) throws InterruptedException &#123;</span><br><span class="line">        work &#x3D; new NioEventLoopGroup();</span><br><span class="line">        bootstrap.group(work)</span><br><span class="line">                .channel(NioSocketChannel.class) &#x2F;&#x2F;</span><br><span class="line">                .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(new EncoderHandler());</span><br><span class="line">                        ch.pipeline().addLast(new ClientInHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            bootstrap.connect(inetHost, inetPort).addListener((listener) -&gt; &#123;</span><br><span class="line">                if (listener.isSuccess()) &#123;</span><br><span class="line">                    System.out.println(&quot;连接成功&quot;);</span><br><span class="line">                    ChannelFuture future &#x3D; (ChannelFuture) listener;</span><br><span class="line">                    startConsoleThread(future.channel());  &#x2F;&#x2F; 开启控制台线程</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="socketio实例分析"><a href="#socketio实例分析" class="headerlink" title="socketio实例分析"></a>socketio实例分析</h2><p>分析的是github上socketio这个项目 <a href="https://github.com/mrniko/netty-socketio/">https://github.com/mrniko/netty-socketio/</a></p><p>Socket.IO server implemented on Java. Realtime java framework</p><p>用netty实现的实时网络通信</p><h3 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h3><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>在一个命名空间空间的所有客户端都是共享的</p><p>那共享的都有什么呢？一个一个分析</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614920618711-1ada87d2-c22c-424a-a609-0c98624dbbfa.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>先看ScannerEngine类内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># ScannerEngine.class</span><br><span class="line">    </span><br><span class="line">public void scan(Namespace namespace, Object object, Class&lt;?&gt; clazz)</span><br><span class="line">            throws IllegalArgumentException &#123;</span><br><span class="line">        Method[] methods &#x3D; clazz.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 类不是Object类型的</span><br><span class="line">        if (!clazz.isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                for (AnnotationScanner annotationScanner : annotations) &#123;</span><br><span class="line">                    Annotation ann &#x3D; method.getAnnotation(annotationScanner.getScanAnnotation());</span><br><span class="line">                    if (ann !&#x3D; null) &#123;</span><br><span class="line">                        annotationScanner.validate(method, clazz);</span><br><span class="line"></span><br><span class="line">                        Method m &#x3D; findSimilarMethod(object.getClass(), method);</span><br><span class="line">                        if (m !&#x3D; null) &#123;</span><br><span class="line">                            annotationScanner.addListener(namespace, object, m, ann);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            log.warn(&quot;Method similar to &quot; + method.getName() + &quot; can&#39;t be found in &quot; + object.getClass());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; -----------------主要看这段--------------------------</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                for (AnnotationScanner annotationScanner : annotations) &#123;</span><br><span class="line">                    Annotation ann &#x3D; method.getAnnotation(annotationScanner.getScanAnnotation());</span><br><span class="line">                    if (ann !&#x3D; null) &#123;</span><br><span class="line">                        annotationScanner.validate(method, clazz);</span><br><span class="line">                        makeAccessible(method);</span><br><span class="line">                        annotationScanner.addListener(namespace, object, method, ann);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#x2F;&#x2F; -----------------end--------------------------</span><br><span class="line">            if (clazz.getSuperclass() !&#x3D; null) &#123;</span><br><span class="line">                scan(namespace, object, clazz.getSuperclass());</span><br><span class="line">            &#125; else if (clazz.isInterface()) &#123;</span><br><span class="line">                for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) &#123;</span><br><span class="line">                    scan(namespace, object, superIfc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先说这段代码干嘛的，去扫描类里面的方法，有没有带有这三个注解的方法，如果有的话，把相应的下图三个监听器添加到相应命名空间下的执行队列中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921713851-7997ddad-d955-4573-b8d9-0967228615f4.png" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921813582-a02626b3-2473-42f9-832a-0424577f9a92.png" alt="image.png"></p><p>所以ScannerEngine类就是扫描注解，然后添加监听器。加个上面三个注解的方法都会添加到监听器中。</p><p>NameSpace这个对象拿着ScannerEngine引擎去查找带注解的方法，并添加到NameSpace中。</p><p>eventListeners、connectListeners、disconnectListeners</p><p>这三个就不要特别说明了，是三个不同类别的监听器，分别在不同时期进行执行。</p><p>pingListeners也是同理</p><p>allClients是在这个命名空间下所有的客户端， SocketIOClient是客户端实体</p><p>roomClients是房间内的客户端，就算是分组把</p><p>clientRooms是房间，也就是组。可以移除客户端也可以添加。</p><h4 id="NameSpaceHub"><a href="#NameSpaceHub" class="headerlink" title="NameSpaceHub"></a>NameSpaceHub</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923575816-c1e9f0ca-b3e7-4941-84c3-85bbe741e7c1.png" alt="image.png"></p><p>用来操作NameSpaceHub的，主要是创建、获取移除等等，同时可以看到所有的NameSpace。</p><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923846574-f407d315-a478-4bcf-878d-5cbf561b1fb3.png" alt="image.png"></p><p>因为在使用Netty过程中我们要自定义协议格式，这里Packet就是数据协议包，AuthPacket是一个认证的协议包。</p><p>剩下都是围绕Packet的一些工具。比如PacketDecoder或者PacketEncoder这种编码解码工具、Json序列化的工具等等。</p><p>重点说下Packet包</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923992993-0a7ce29c-e754-48ef-bf3c-ef7b1fae200b.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>data数据、nsp命名空间、ackId唯一标识，可能用于消息确认等其他用途、type、subType都是包的类型</p><p>包的类型又分为下面这些</p><p><em><strong>#PacketType.java</strong></em></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924404084-776ee465-968b-4e16-ab5c-0cd87dc67832.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>类型Connect、Disconnect或者是Event或者是Ackd等等</p><p>回到上图这个attachments我也没明白，应该是可以自定义的一些字段，附件，方便扩展。同时还需要进行初始化</p><p><em><strong>#Packet.java</strong></em></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924500498-1170a570-9d64-40cc-89fe-535e6b8bc16c.png" alt="image.png"></p><p>Packet包里面的数据就是data，data经过***#PacketEncoder***编码后就变了ByteBuf，Netty就可以在Channel中传输了，下图是编码的过程</p><p><em><strong>#PacketEncoder.java</strong></em></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614925102874-bfc4aba2-6291-45c2-b661-6c9f2ac75d16.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>…. 未完待续</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="2020/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h2><p>XA 是 X/Open CAE Specification (Distributed Transaction Processing)模型，它定义的 TM（Transaction Manager）与 RM（Resource Manager）之间进行通信的接口。</p><p><img src="http://static.iocoder.cn/c8f27f0e1107c328476600c4ed2608ec" alt="强 XA 的顺序图"></p><ul><li>二阶段提交是 XA 的标准实现。它将分布式事务的提交拆分为 2 个阶段：prepare 和 commit/rollback 。<ul><li>第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</li><li>第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。</li></ul></li><li>开启 XA 全局事务后，所有子事务会按照本地默认的隔离级别锁定资源，并记录 undo 和 redo 日志。然后由 TM 发起 prepare 投票，询问所有的子事务是否可以进行提交：<ul><li>当所有子事务反馈的结果为 “yes” 时，TM 再发起 commit 。</li><li>若其中任何一个子事务反馈的结果为“no”，TM 则发起 rollback 。</li><li>如果在 prepare 阶段的反馈结果为 “yes” ，而 commit 的过程中出现宕机等异常时，则在节点服务重启后，可根据 XA recover 再次进行 commit 补偿，以保证数据的一致性。</li></ul></li></ul><h3 id="XA出现的问题"><a href="#XA出现的问题" class="headerlink" title="XA出现的问题"></a>XA出现的问题</h3><ul><li><p>单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</p></li><li><p>同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</p></li><li><p>数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p></li></ul><p> <strong>解决方案</strong></p><ul><li><p>Sharding Sphere</p><blockquote><p>Sharding Sphere 支持基于 XA 的强一致性事务解决方案，可以通过 SPI 注入不同的第三方组件作为事务管理器实现 XA 协议，如 Atomikos 和 Narayana 。</p></blockquote></li><li><p>Spring JTA + Atomikos</p></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。</p><p>这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p><p><a href="http://static.iocoder.cn/baef17d9dde837632e9a7894cb825cb2"><img src="http://static.iocoder.cn/baef17d9dde837632e9a7894cb825cb2" alt="distributed-transacion-XA"></a>distributed-transacion-XA</p><h2 id="利用消息可靠性保证最终一致性"><a href="#利用消息可靠性保证最终一致性" class="headerlink" title="利用消息可靠性保证最终一致性"></a>利用消息可靠性保证最终一致性</h2><p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><p><a href="http://static.iocoder.cn/80a431c9be51ed67d9c67f7a1de7c2ed"><img src="http://static.iocoder.cn/80a431c9be51ed67d9c67f7a1de7c2ed" alt="distributed-transaction-reliable-message"></a></p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>RocketMQ 事务消息</li><li>RabbitMQ消息确认机制</li><li>Kafka事务消息</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka消费者</title>
      <link href="2020/11/02/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>2020/11/02/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka消费者"><a href="#Kafka消费者" class="headerlink" title="Kafka消费者"></a>Kafka消费者</h1><p>消费者从属于消费群组</p><p>Kafka分为主题和分区，主题包括分区， 分区是个有序队列。</p><p>消费者订阅主题，处理主题里分区的消息。如果想要有序处理，那么就讲消费者和分区进行绑定。</p><h3 id="消费者、消费者群组和分区关系"><a href="#消费者、消费者群组和分区关系" class="headerlink" title="消费者、消费者群组和分区关系"></a>消费者、消费者群组和分区关系</h3><p>通常，一个主题会对应一个消费群组，消费群组的消费能力取决于消费者的个数。一个消费者对应一个分区或者多个分区。</p><p>同一个分区内的消息只能被同一个消费者群组中的一个消费者消费</p><p>但是可以被多个消费者群组消费。</p><p>消费者 &gt; 分区，消费者过多，有消费者消费能力失效</p><p>如果两个消费群组对应一个主题</p><p>消费能力就是之前的两倍，但是每个消费者群组里面依然和上面相同</p><p>当然，如果消费者能力很强，是可以处理多个分区的。</p><p>消费者群组具有伸缩读取能力和处理能力，群组里的每个消费者只处理部分消息。</p><p>如果分区的消息还没处理完，需要转移到另外一个消费者，这个过程就需要再均衡。</p><h3 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h3><p>再均衡的过程就是消费者对分区失去所有权的过程，所以再失去所有权之前要把自己处理记录的偏移量记录下来。</p><p>Kafka设计了一个再均衡监听器</p><p><em><strong>ConsumerRebalanceListener.class</strong></em> </p><p>实现接口的两个方法分别是***#onPartitionsRevoked*** 和 <em><strong>#onPartitonsAssigned</strong></em></p><p>Revoked 是消费者停止读取消息之后被调用，在这里提交最后的偏移量</p><p>Assigned 再均衡之后，消费者开始读取消息之前调用。</p><p>这里涉及到偏移量提交的问题，偏移量是如何提交的</p><p>再均衡会做一些清理工作</p><ol><li><p>关闭数据库连接</p></li><li><p>关闭文件具柄</p></li><li><p>缓冲区遗留的记录</p></li><li><p>…</p></li></ol><h3 id="偏移量的提交"><a href="#偏移量的提交" class="headerlink" title="偏移量的提交"></a>偏移量的提交</h3><h4 id="同步提交"><a href="#同步提交" class="headerlink" title="同步提交"></a>同步提交</h4><p>分为手动提交和自动提交</p><p>自动提交</p><p>每5s,消费者会自动提交</p><p>手动提交就不基于时间间隔，使用commitSync()提交偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     consumer.commitSycn();</span><br><span class="line">   &#125;<span class="keyword">catch</span>(CommitFailedException e) &#123;</span><br><span class="line">     log.error(<span class="string">&quot;commit failed&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：会限制吞吐量， 降低频率又回带来消息重复的问题</p><h4 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h4><p>commitAsync();</p><p>提交后就反回，虽然解决了上述的问题，但是也带来了新的问题，顺序问题。</p><p>如果重试会带来顺序错误问题，就会带来消息重复消费的问题。</p><p>可以通过回调的方式处理</p><p>在重试前，先检查回调的序列好和即将提交的偏移量是否相等。相等可以提交，如果序列号偏大，需要停止重试。</p><h4 id="同步和异步组合提交"><a href="#同步和异步组合提交" class="headerlink" title="同步和异步组合提交"></a>同步和异步组合提交</h4><p>提交偏移量的重点在于提交最后一个偏移量</p><p>组合提交，异步正常提交，同步进行重试</p><h4 id="提交特定偏移量"><a href="#提交特定偏移量" class="headerlink" title="提交特定偏移量"></a>提交特定偏移量</h4><p>通过map记录偏移量相关信息。</p><p>然后再通过commitAsync或者commitSync尽心提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">ConsumerRecords.class <span class="comment">//消费者记录</span></span><br><span class="line">  </span><br><span class="line">ConsumerRecord records = consumer.poll(<span class="number">100</span>); <span class="comment">//拉取100s内的数据返回消费者端</span></span><br><span class="line"></span><br><span class="line">records.forEach( record -&gt; &#123;</span><br><span class="line">  record.offset(); <span class="comment">// 偏移量</span></span><br><span class="line">  cosummer.commitAsync(...);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql下的join buffer</title>
      <link href="2020/07/10/mysql%E4%B8%8B%E7%9A%84join%20buffer/"/>
      <url>2020/07/10/mysql%E4%B8%8B%E7%9A%84join%20buffer/</url>
      
        <content type="html"><![CDATA[<p>我们在查询的时候，通过explain可以看到经常有使用join buffer（Using join buffer(Block Nested Loop)</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375660c0e7449d?w=2538&h=372&f=png&s=82383"></p><p>要想知道join buffer，就是先知道join运行的原理。</p><h2 id="嵌套循环连接（Nested-Loop-Join）"><a href="#嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="嵌套循环连接（Nested-Loop Join）"></a>嵌套循环连接（Nested-Loop Join）</h2><p><a href="https://juejin.im/book/6844733769996304392/section/6844733770055024654">详细请参考掘金小册《Mysql是怎样运行的》</a></p><p>join的原理就是嵌套循环连接，驱动表作为第一层，被驱动表作为第二层，情况基本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 驱动表的每行记录 <span class="keyword">in</span> 驱动表的记录</span><br><span class="line"><span class="keyword">for</span> 被驱动表每行记录 <span class="keyword">in</span> 被驱动表的记录</span><br><span class="line"><span class="keyword">if</span> (on条件（驱动表的每行记录，被驱动表的每行记录）？<span class="keyword">return</span> true : false</span><br></pre></td></tr></table></figure><p>时间复杂度为 count(驱动表的记录) x count(被驱动表) </p><p>比如：有一张课程表course</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">course                                teacher</span><br><span class="line">---------------------                 ------------------------</span><br><span class="line">course_id| teacher_id                 teacher_id| teacher_name</span><br><span class="line">---------------------                 ------------------------</span><br><span class="line"><span class="number">1</span>        | <span class="number">1</span>                          <span class="number">1</span>         | leo</span><br><span class="line">---------------------                 ------------------------</span><br><span class="line"><span class="number">2</span>        | <span class="number">2</span>                          <span class="number">2</span>         | john</span><br><span class="line">---------------------                 ------------------------</span><br></pre></td></tr></table></figure><p>sql语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course <span class="keyword">left</span> <span class="keyword">join</span> teacher </span><br><span class="line"><span class="keyword">on</span> course.teacher_id <span class="operator">=</span> teacher.teacher_id </span><br><span class="line"><span class="keyword">where</span> course_id <span class="operator">&gt;</span> <span class="number">0</span>。</span><br></pre></td></tr></table></figure><p>因为是左连接，cource为驱动表， teacher为被驱动表。</p><ol><li><p><strong>第一步筛选出驱动表符合条件的记录</strong></p><p>mysql 查询的时候先根据where条件进行对course的单表查询, 查询出的每一条记录都要在与teacher进行一次查询匹配。例如，where course_id &gt; 0, 那么从course表中拿到第一条记录的时候发现是&gt;0的，可以留下，然后该去teacher表中进行匹配了。</p></li><li><p><strong>通过连接条件on后的条件对被驱动表的数据筛选</strong></p><p>第一条的teacher_id 为1，on 条件为teacher_id 相等，也就是我们在teacher表中执行如下的单表查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from teacher where teacher_id = <span class="number">1</span> </span><br></pre></td></tr></table></figure><p>那么这条记录如果没有加任何索引，执行中要查询的就是这个teacher表中的所有记录。</p></li></ol><p><strong>3. 将查询的结果与驱动表进行连接并返回给客户端</strong></p><p>连接就要根据左连接还是右连接进行匹配了，没有的加null值，等等。</p><h2 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="基于块的嵌套循环连接（Block Nested-Loop Join）"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h2><p>这样一条一条的查就像双重循环，效率低下，被驱动表如果数据量大会出现性能瓶颈。</p><p>我们可以思考几个问题：</p><ul><li>每一条驱动表的记录去被驱动表进行条件匹配的时候，重复匹配了多次，我们是否加个缓存来解决？</li><li>缓存的目的是什么？</li><li>如果加缓存，这个缓存应该加在哪，驱动表还是被驱动表？</li></ul><p>首先我们加缓存的目的是为了取一次数据尽量不被舍弃，可以多次复用。我们查询了很多次被驱动表，如果查询了一次就被缓存下来，在内存中进行数据的匹配操作，效率会高很多。但是会出现一个问题，被驱动表往往是数据量大的一方，被驱动表也可以是多个。所以缓存被驱动表到内存不现实。我们可以反向来想，缓存驱动表。将驱动表的筛选出的所有数据进行缓存，然后每次从被驱动表拿来的数据都与缓存的驱动表的所有记录进行匹配，符合条件的都留下来。这样被驱动表的每条记录只取一次就可以了。</p><p>所以join_buffer 就是这个缓冲区，join buffer就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配。join_buffer 就是这个内存块。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/1737563b590bb0c5?w=826&h=479&f=png&s=104174"></p><p>复杂度也从O(n^2) 变成了 O(n)</p><h2 id="MySQL如何使用联接缓冲区缓存"><a href="#MySQL如何使用联接缓冲区缓存" class="headerlink" title="MySQL如何使用联接缓冲区缓存"></a>MySQL如何使用联接缓冲区缓存</h2><p>上面所有说的过程都是在被驱动表查询类型是ALL或者Index, 也就是进行全盘扫描，没有加索引，也不是等值连接这种情况下。</p><p><a href="https://dev.mysql.com/doc/internals/en/join-buffer-size.html">官方文档定义</a>：</p><p>Basic information about the join buffer cache:</p><ul><li>The size of each join buffer is determined by the value of the <code>join_buffer_size</code> system variable.</li><li><em><strong>This buffer is used only when the join is of type <code>ALL</code> or <code>index</code> (in other words, when no possible keys can be used).</strong></em></li><li>A join buffer is never allocated for the first non-const table, even if it would be of type <code>ALL</code> or <code>index</code>.</li><li>The buffer is allocated when we need to do a full join between two tables, and freed after the query is done.</li><li>Accepted row combinations of tables before the <code>ALL</code>/<code>index</code> are stored in the cache and are used to compare against each read row in the <code>ALL</code> table.</li><li><em><strong>We only store the used columns in the join buffer, not the whole rows.</strong></em></li></ul><p>上面说，仅仅是在type 为ALL 或者 index 条件下，为什么？</p><p>当然是因为使用其他计算方法效率更高，比如我们驱动表进行条件筛选的时候，where teacher_id =1 , 给teacher_id 加上索引就不需要筛选被驱动表中的所有数据，这样的效率更高。只有在Mysql优化器认定type为ALL的时候才<strong>可能</strong>会去用join_buffer</p><p>最后一句说：我们仅仅存储使用到的列，而不是整个行</p><p>join_buffer存储的是驱动表中用到的列的数据，比如course表，记录还是两条，但是每条记录里只有teacher_id而没有course_id。</p><p>所以要纠正一下上文中的说话，比如记录啊、每一行并不是真的指行里所有的数据，只是需要用到的列的数据。</p><p>在看下官方的定义的执行步骤：</p><p>假设您具有以下联接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> name      Type</span><br><span class="line">t1              <span class="keyword">range</span></span><br><span class="line">t2              <span class="keyword">ref</span></span><br><span class="line">t3              <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p>然后按以下步骤完成连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> While <span class="keyword">rows</span> <span class="keyword">in</span> t1 matching <span class="keyword">range</span></span><br><span class="line"> <span class="operator">-</span> Read through <span class="keyword">all</span> <span class="keyword">rows</span> <span class="keyword">in</span> t2 according <span class="keyword">to</span> reference key</span><br><span class="line">  <span class="operator">-</span> Store used fields <span class="keyword">from</span> t1, t2 <span class="keyword">in</span> cache</span><br><span class="line">  <span class="operator">-</span> If cache <span class="keyword">is</span> <span class="keyword">full</span></span><br><span class="line">    <span class="operator">-</span> Read through <span class="keyword">all</span> <span class="keyword">rows</span> <span class="keyword">in</span> t3</span><br><span class="line">      <span class="operator">-</span> Compare t3 <span class="type">row</span> against <span class="keyword">all</span> t1, t2 combinations <span class="keyword">in</span> cache</span><br><span class="line">        <span class="operator">-</span> If <span class="type">row</span> satisfies <span class="keyword">join</span> <span class="keyword">condition</span>, send it <span class="keyword">to</span> client</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">Empty</span> cache</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> Read through <span class="keyword">all</span> <span class="keyword">rows</span> <span class="keyword">in</span> t3</span><br><span class="line"> <span class="operator">-</span> Compare t3 <span class="type">row</span> against <span class="keyword">all</span> stored t1, t2 combinations <span class="keyword">in</span> cache</span><br><span class="line">   <span class="operator">-</span> If <span class="type">row</span> satisfies <span class="keyword">join</span> <span class="keyword">condition</span>, send it <span class="keyword">to</span> client</span><br></pre></td></tr></table></figure><p>前面的描述意味着<code>t3</code>扫描表的次数 确定如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S <span class="operator">=</span> size<span class="operator">-</span><span class="keyword">of</span><span class="operator">-</span>stored<span class="operator">-</span><span class="type">row</span>(t1,t2)</span><br><span class="line">C <span class="operator">=</span> accepted<span class="operator">-</span><span class="type">row</span><span class="operator">-</span>combinations(t1,t2)</span><br><span class="line">scans <span class="operator">=</span> (S <span class="operator">*</span> C)<span class="operator">/</span>join_buffer_size <span class="operator">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>t1 range ,t2 ref ，所以这部分没有用join_buffer，而是将t1和t2匹配的结果缓存在缓冲区</p><p><a href=""></a></p><p>t3 为all, 读取的时候拿出t3的每一行与t1和t2缓存进行比较。</p><p><a href=""></a></p><p>扫描的行数为</p><p>scans = (S * C)/join_buffer_size + 1</p><p>这个join_buffer 也是有一定大小的，如果驱动表&gt; join_buffer，就需要分多次。所以上面要除以/join_buffer_size</p><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><p>Some conclusions:</p><ul><li><p>The larger the value of <code>join_buffer_size</code>, the fewer the scans of <code>t3</code>. If <code>join_buffer_size</code> is already large enough to hold all previous row combinations, there is no speed to be gained by making it larger.</p></li><li><p>If there are several tables of join type <code>ALL</code> or <code>index</code>, then we allocate one buffer of size <code>join_buffer_size</code> for each of them and use the same algorithm described above to handle it. (In other words, we store the same row combination several times into different buffers.)</p></li><li><p>值越大<code>join_buffer_size</code>，扫描的次数越少<code>t3</code>。如果 <code>join_buffer_size</code>已经足够大以容纳所有先前的行组合，则使其变大无法获得任何速度。</p></li><li><p>如果有多个联接类型为<code>ALL</code>或的表<code>index</code>，则我们<code>join_buffer_size</code>为每个表 分配一个大小相同的缓冲区， 并使用上述相同的算法进行处理。（换句话说，我们将同一行组合多次存储到不同的缓冲区中。）</p></li></ul><p><strong>参考 《MySQL 是怎样运行的：从根儿上理解 MySQL》 作者:小孩子4919</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解ReentrantLock的实现原理[转载]</title>
      <link href="2020/07/02/ReentrantLock/"/>
      <url>2020/07/02/ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h1 id="转载-深入理解ReentrantLock的实现原理"><a href="#转载-深入理解ReentrantLock的实现原理" class="headerlink" title="[转载]深入理解ReentrantLock的实现原理"></a>[转载]深入理解ReentrantLock的实现原理</h1><p>转：<a href="https://juejin.cn/post/6844903805683761165">深入理解ReentrantLock的实现原理</a></p><h2 id="ReentrantLock简介"><a href="#ReentrantLock简介" class="headerlink" title="ReentrantLock简介"></a>ReentrantLock简介</h2><p><code>ReentrantLock</code>是<code>Java</code>在<code>JDK1.5</code>引入的显式锁，在实现原理和功能上都和内置锁(synchronized)上都有区别，在文章最后我们再比较这两个锁。<br> 首先我们要知道<code>ReentrantLock</code>是基于<code>AQS</code>实现的，所以我们得对<code>AQS</code>有所了解才能更好的去学习掌握<code>ReentrantLock</code>，关于<code>AQS</code>的介绍可以参考我之前写的一篇文章<a href="https://ddnd.cn/2019/03/15/java-abstractqueuedsynchronizer/">《一文带你快速掌握AQS》</a>，这里简单回顾下<code>AQS</code>。</p><h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p>通过前面的回顾，是不是对<code>ReentrantLock</code>有了一定的了解了，<code>ReentrantLock</code>通过重写<strong>锁获取方式</strong>和<strong>锁释放方式</strong>这两个方法实现了<strong>公平锁</strong>和<strong>非公平锁</strong>，那么<code>ReentrantLock</code>是怎么重写的呢，这也就是本节需要探讨的问题。</p><h3 id="ReentrantLock结构"><a href="#ReentrantLock结构" class="headerlink" title="ReentrantLock结构"></a>ReentrantLock结构</h3><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aa1836d0ac5b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>首先<code>ReentrantLock</code>继承自父类<code>Lock</code>，然后有<code>3</code>个内部类，其中<code>Sync</code>内部类继承自<code>AQS</code>，另外的两个内部类继承自<code>Sync</code>，这两个类分别是用来<strong>公平锁和非公平锁</strong>的。<br> 通过<code>Sync</code>重写的方法<code>tryAcquire</code>、<code>tryRelease</code>可以知道，**<code>ReentrantLock</code>实现的是<code>AQS</code>的独占模式，也就是独占锁，这个锁是悲观锁**。</p><p><code>ReentrantLock</code>有个重要的成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final Sync sync;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个变量是用来指向<code>Sync</code>的子类的，也就是<code>FairSync</code>或者<code>NonfairSync</code>，这个也就是多态的<strong>父类引用指向子类</strong>，具体<code>Sycn</code>指向哪个子类，看构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>有两个构造方法，无参构造方法默认是创建<strong>非公平锁</strong>，而传入<code>true</code>为参数的构造方法创建的是<strong>公平锁</strong>。</p><h3 id="非公平锁的实现原理"><a href="#非公平锁的实现原理" class="headerlink" title="非公平锁的实现原理"></a>非公平锁的实现原理</h3><p>当我们使用无参构造方法构造的时候即<code>ReentrantLock lock = new ReentrantLock()</code>，创建的就是非公平锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者传入false参数 创建的也是非公平锁</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lock方法获取锁"><a href="#lock方法获取锁" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li><code>lock</code>方法调用<code>CAS</code>方法设置<code>state</code>的值，如果<code>state</code>等于期望值<code>0</code>(代表锁没有被占用)，那么就将<code>state</code>更新为<code>1</code>(代表该线程获取锁成功)，然后执行<code>setExclusiveOwnerThread</code>方法直接将该线程设置成锁的所有者。如果<code>CAS</code>设置<code>state</code>的值失败，即<code>state</code>不等于<code>0</code>，代表锁正在被占领着，则执行<code>acquire(1)</code>，即下面的步骤。</li><li><code>nonfairTryAcquire</code>方法首先调用<code>getState</code>方法获取<code>state</code>的值，如果<code>state</code>的值为<code>0</code>(之前占领锁的线程刚好释放了锁)，那么用<code>CAS</code>这是<code>state</code>的值，设置成功则将该线程设置成锁的所有者，并且返回<code>true</code>。如果<code>state</code>的值不为<code>0</code>，那就<strong>调用<code>getExclusiveOwnerThread</code>方法查看占用锁的线程是不是自己</strong>，如果是的话那就直接将<code>state + 1</code>，然后返回<code>true</code>。如果<code>state</code>不为<code>0</code>且锁的所有者又不是自己，那就返回<code>false</code>，<strong>然后线程会进入到同步队列中</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aab7befb2e5de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    &#x2F;&#x2F;CAS操作设置state的值</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        &#x2F;&#x2F;设置成功 直接将锁的所有者设置为当前线程 流程结束</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        &#x2F;&#x2F;设置失败 则进行后续的加入同步队列准备</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用子类重写的tryAcquire方法 如果tryAcquire方法返回false 那么线程就会进入同步队列</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类重写的tryAcquire方法</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    &#x2F;&#x2F;调用nonfairTryAcquire方法</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    &#x2F;&#x2F;如果状态state&#x3D;0，即在这段时间内 锁的所有者把锁释放了 那么这里state就为0</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;使用CAS操作设置state的值</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            &#x2F;&#x2F;操作成功 则将锁的所有者设置成当前线程 且返回true，也就是当前线程不会进入同步</span><br><span class="line">            &#x2F;&#x2F;队列。</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果状态state不等于0，也就是有线程正在占用锁，那么先检查一下这个线程是不是自己</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果线程就是自己了，那么直接将state+1，返回true，不需要再获取锁 因为锁就在自己</span><br><span class="line">        &#x2F;&#x2F;身上了。</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果state不等于0，且锁的所有者又不是自己，那么线程就会进入到同步队列。</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="tryRelease锁的释放"><a href="#tryRelease锁的释放" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><ol><li>判断当前线程是不是锁的所有者，如果是则进行步骤<code>2</code>，如果不是则抛出异常。</li><li>判断此次释放锁后<code>state</code>的值是否为0，如果是则代表<strong>锁有没有重入</strong>，然后将锁的所有者设置成<code>null</code>且返回<code>true</code>，然后执行步骤<code>3</code>，如果不是则<strong>代表锁发生了重入</strong>执行步骤<code>4</code>。</li><li>现在锁已经释放完，即<code>state=0</code>，唤醒同步队列中的后继节点进行锁的获取。</li><li>锁还没有释放完，即<code>state!=0</code>，不唤醒同步队列。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169aad4a8e578933?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;子类重写的tryRelease方法，需要等锁的state&#x3D;0，即tryRelease返回true的时候，才会去唤醒其</span><br><span class="line">    &#x2F;&#x2F;它线程进行尝试获取锁。</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;状态的state减去releases</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    &#x2F;&#x2F;判断锁的所有者是不是该线程</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        &#x2F;&#x2F;如果所的所有者不是该线程 则抛出异常 也就是锁释放的前提是线程拥有这个锁，</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;如果该线程释放锁之后 状态state&#x3D;0，即锁没有重入，那么直接将将锁的所有者设置成null</span><br><span class="line">    &#x2F;&#x2F;并且返回true，即代表可以唤醒其他线程去获取锁了。如果该线程释放锁之后state不等于0，</span><br><span class="line">    &#x2F;&#x2F;那么代表锁重入了，返回false，代表锁还未正在释放，不用去唤醒其他线程。</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="公平锁的实现原理"><a href="#公平锁的实现原理" class="headerlink" title="公平锁的实现原理"></a>公平锁的实现原理</h3><h4 id="lock方法获取锁-1"><a href="#lock方法获取锁-1" class="headerlink" title="lock方法获取锁"></a>lock方法获取锁</h4><ol><li>获取状态的<code>state</code>的值，如果<code>state=0</code>即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，执行步骤<code>2</code>。如果<code>state!=0</code>则代表锁正在被其它线程占用，执行步骤<code>3</code>。</li><li><strong>判断同步队列是否存在线程(节点)，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。</strong></li><li><strong>判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中</strong></li></ol><p>通过步骤<code>2</code><strong>实现了锁获取的公平性，即锁的获取按照先来先得的顺序，后来的不能抢先获取锁，非公平锁和公平锁也正是通过这个区别来实现了锁的公平性。</strong></p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="878" height="662"></svg>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;同步队列中有线程 且 锁的所有者不是当前线程那么将线程加入到同步队列的尾部，</span><br><span class="line">    &#x2F;&#x2F;保证了公平性，也就是先来的线程先获得锁，后来的不能抢先获取。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    &#x2F;&#x2F;判断状态state是否等于0，等于0代表锁没有被占用，不等于0则代表锁被占用着。</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;调用hasQueuedPredecessors方法判断同步队列中是否有线程在等待，如果同步队列中没有</span><br><span class="line">        &#x2F;&#x2F;线程在等待 则当前线程成为锁的所有者，如果同步队列中有线程在等待，则继续往下执行</span><br><span class="line">        &#x2F;&#x2F;这个机制就是公平锁的机制，也就是先让先来的线程获取锁，后来的不能抢先获取。</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断当前线程是否为锁的所有者，如果是，那么直接更新状态state，然后返回true。</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果同步队列中有线程存在 且 锁的所有者不是当前线程，则返回false。</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="tryRelease锁的释放-1"><a href="#tryRelease锁的释放-1" class="headerlink" title="tryRelease锁的释放"></a>tryRelease锁的释放</h4><p>公平锁的释放和非公平锁的释放一样，这里就不重复。<br> 公平锁和非公平锁的公平性是在<strong>获取锁</strong>的时候体现出来的，释放的时候都是一样释放的。</p><h3 id="lockInterruptibly可中断方式获取锁"><a href="#lockInterruptibly可中断方式获取锁" class="headerlink" title="lockInterruptibly可中断方式获取锁"></a>lockInterruptibly可中断方式获取锁</h3><p><code>ReentrantLock</code>相对于<code>Synchronized</code>拥有一些更方便的特性，比如可以中断的方式去获取锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;如果当前线程已经中断了，那么抛出异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    &#x2F;&#x2F;如果当前线程仍然未成功获取锁，则调用doAcquireInterruptibly方法，这个方法和</span><br><span class="line">    &#x2F;&#x2F;acquireQueued方法没什么区别，就是线程在等待状态的过程中，如果线程被中断，线程会</span><br><span class="line">    &#x2F;&#x2F;抛出异常。</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="tryLock超时等待方式获取锁"><a href="#tryLock超时等待方式获取锁" class="headerlink" title="tryLock超时等待方式获取锁"></a>tryLock超时等待方式获取锁</h3><p><code>ReentrantLock</code>除了能以能中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回<code>false</code>，而不是一直”死循环”获取。</p><ol><li>判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用<code>doAcquireNanos</code>方法使用超时等待的方式获取锁。</li><li>将当前节点封装成独占模式的节点加入到同步队列的队尾中。</li><li>进入到”死循环”中，<strong>但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回<code>false</code>，结束循环</strong>。这里调用的是<code>LockSupport.parkNanos</code>方法，在超时时间内没有被中断，那么线程会从<strong>超时等待状态转成了就绪状态</strong>，然后被<code>CPU</code>调度继续执行循环，<strong>而这时候线程已经达到超时等到的时间，返回false</strong>。</li></ol><blockquote><p><code>LockSuport</code>的方法能响应<code>Thread.interrupt</code>，但是不会抛出异常</p></blockquote><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="931" height="877"></svg>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;如果当前线程已经中断了  则抛出异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    &#x2F;&#x2F;再尝试获取一次 如果不成功则调用doAcquireNanos方法进行超时等待获取锁</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean doAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">        return false;</span><br><span class="line">    &#x2F;&#x2F;计算超时的时间 即当前虚拟机的时间+设置的超时时间</span><br><span class="line">    final long deadline &#x3D; System.nanoTime() + nanosTimeout;</span><br><span class="line">    &#x2F;&#x2F;调用addWaiter将当前线程封装成独占模式的节点 并且加入到同步队列尾部</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F;如果当前节点的前驱节点为头结点 则让当前节点去尝试获取锁。</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                &#x2F;&#x2F;当前节点获取锁成功 则将当前节点设置为头结点，然后返回true。</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果当前节点的前驱节点不是头结点 或者 当前节点获取锁失败，</span><br><span class="line">            &#x2F;&#x2F;则再次判断当前线程是否已经超时。</span><br><span class="line">            nanosTimeout &#x3D; deadline - System.nanoTime();</span><br><span class="line">            if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F;调用shouldParkAfterFailedAcquire方法，告诉当前节点的前驱节点 我要进入</span><br><span class="line">            &#x2F;&#x2F;等待状态了，到我了记得喊我，即做好进入等待状态前的准备。</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                &#x2F;&#x2F;调用LockSupport.parkNanos方法，将当前线程设置成超时等待的状态。</span><br><span class="line">                LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock的等待-通知机制"><a href="#ReentrantLock的等待-通知机制" class="headerlink" title="ReentrantLock的等待/通知机制"></a>ReentrantLock的等待/通知机制</h3><p>我们知道关键字<code>Synchronized</code> + <code>Object</code>的<code>wait</code>和<code>notify</code>、<code>notifyAll</code>方法能实现<strong>等待/通知</strong>机制，那么<code>ReentrantLock</code>是否也能实现这样的等待/通知机制，答案是：可以。<br> <code>ReentrantLock</code>通过<code>Condition</code>对象，也就是<strong>条件队列</strong>实现了和<code>wait</code>、<code>notify</code>、<code>notifyAll</code>相同的语义。 线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到条件队列中。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1210" height="261"></svg>)</p><p>线程执行<code>condition.signal()</code>方法，将节点1从条件队列中转移到同步队列。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1217" height="223"></svg>)</p><p>因为只有在同步队列中的线程才能去获取锁，所以通过<code>Condition</code>对象的<code>wait</code>和<code>signal</code>方法能实现等待/通知机制。<br> 代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line">public void await() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;线程获取锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.await(); &#x2F;&#x2F;调用await()方法 会释放锁，和Object.wait()效果一样。</span><br><span class="line">        System.out.println(&quot;线程被唤醒----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void signal() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000);  &#x2F;&#x2F;休眠1秒钟 等等一个线程先执行</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;另外一个线程获取到锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">        condition.signal();</span><br><span class="line">        System.out.println(&quot;唤醒线程----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(&quot;另外一个线程释放锁----&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Test t &#x3D; new Test();</span><br><span class="line">    Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            t.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程获取锁----Thread-0</span><br><span class="line">另外一个线程获取到锁----Thread-1</span><br><span class="line">唤醒线程----Thread-1</span><br><span class="line">另外一个线程释放锁----Thread-1</span><br><span class="line">线程被唤醒----Thread-0</span><br><span class="line">线程释放锁----Thread-0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>执行的流程大概是这样，线程<code>t1</code>先获取到锁，输出了”线程获取锁—-Thread-0”，然后线程<code>t1</code>调用<code>await</code>方法，调用这个方法的结果就是<strong>线程<code>t1</code>释放了锁进入等待状态，等待唤醒</strong>，接下来线程<code>t2</code>获取到锁，然输出了”另外一个线程获取到锁—-Thread-1”，同时线程<code>t2</code>调用<code>signal</code>方法，调用这个方法的结果就是**唤醒一个在条件队列(Condition)的线程，然后线程<code>t1</code>被唤醒，而这个时候线程<code>t2</code>并没有释放锁，线程<code>t1</code>也就没法获得锁，等线程<code>t2</code>继续执行输出”唤醒线程—-Thread-1”之后线程<code>t2</code>释放锁且输出”另外一个线程释放锁—-Thread-1”，这时候线程<code>t1</code>获得锁，继续往下执行输出了<code>线程被唤醒----Thread-0</code>，然后释放锁输出”线程释放锁—-Thread-0”**。</p><p>如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个<code>Condition</code>对象了，因为<code>ReentrantLock</code>支持创建多个<code>Condition</code>对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为了减少篇幅 仅给出伪代码</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line">Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程1 调用condition.await() 线程进入到条件队列</span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2 调用condition1.await() 线程进入到条件队列</span><br><span class="line">condition1.await();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。</span><br><span class="line">condition1.await();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就实现了部分唤醒的功能。</p><h2 id="ReentrantLock和Synchronized对比"><a href="#ReentrantLock和Synchronized对比" class="headerlink" title="ReentrantLock和Synchronized对比"></a>ReentrantLock和Synchronized对比</h2><p>关于<code>Synchronized</code>的介绍可以看<a href="https://ddnd.cn/2019/03/21/java-synchronized/">《synchronized的使用（一）》</a>、<a href="https://ddnd.cn/2019/03/22/java-synchronized-2/">《深入分析synchronized原理和锁膨胀过程(二)》</a></p><table><thead><tr><th></th><th>ReentrantLock</th><th>Synchronized</th></tr></thead><tbody><tr><td>底层实现</td><td>通过<code>AQS</code>实现</td><td>通过<code>JVM</code>实现，其中<code>synchronized</code>又有多个类型的锁，除了重量级锁是通过<code>monitor</code>对象(操作系统mutex互斥原语)实现外，其它类型的通过对象头实现。</td></tr><tr><td>是否可重入</td><td>是</td><td>是</td></tr><tr><td>公平锁</td><td>是</td><td>否</td></tr><tr><td>非公平锁</td><td>是</td><td>是</td></tr><tr><td>锁的类型</td><td>悲观锁、显式锁</td><td>悲观锁、隐式锁(内置锁)</td></tr><tr><td>是否支持中断</td><td>是</td><td>否</td></tr><tr><td>是否支持超时等待</td><td>是</td><td>否</td></tr><tr><td>是否自动获取/释放锁</td><td>否</td><td>是</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java并发编程的艺术》<br> <a href="https://juejin.im/post/6844903601538596877#heading-10">深入理解AbstractQueuedSynchronizer(AQS)</a><br> <a href="https://www.imooc.com/article/28934">Java 重入锁 ReentrantLock 原理分析)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Volatile的一些理解</title>
      <link href="2020/06/12/Volatile/"/>
      <url>2020/06/12/Volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="Volatile的一些理解"><a href="#Volatile的一些理解" class="headerlink" title="Volatile的一些理解"></a>Volatile的一些理解</h1><p>线程的实时可见性</p><p>禁止指令重排</p><p>为什么要了解透彻一些呢，因为用错过。。。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>先说可见性，指的是当一条线程修改了带有volatile变量的值，新值对于其他所有线程是立即可见的。</p><p>对于正常的变量来说，变量修改完变量的值后，需要通过主内存进行传递，其他线程才知道被更改了。</p><p>volatile变量也可以存在不一致的情况，由于每次使用之前都要刷新，所以是看不到不一致的情况。</p><p>原子性操作好的是没问题的，但是非原子性操作还是会出现问题。</p><p>比如我们常说的 a++ ,其实不是原子性操作，这个应该都知道。</p><p>如果在a++这个过程中发生了并发问题，volatile变量被赋值的时候仍然会出问题</p><blockquote><ol><li>运算结果并不依赖变量的当前值、或者确保只有单一的线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ol></blockquote><h2 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h2><p>java是线程内表现为串行化，但实际执行并非按照编排的指令顺序执行。</p><p>如果多个线程就会出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> flag = true;会被优化，会被提前执行，加了volitile就不会被优化。</p><p>我们如果单线程的话，这个success是永远的都不会反回，返回success。java单线程是保证串行化的。</p><p>当然，如果多线程，每个线程都是按照这个顺序来也都是不会返回的，flag=true都是后执行。</p><p>Volatile性能要比锁高很多。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
