<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebSocket服务端实现</title>
      <link href="2021/08/10/WebSocket%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2021/08/10/WebSocket%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket服务端实现"><a href="#WebSocket服务端实现" class="headerlink" title="WebSocket服务端实现"></a>WebSocket服务端实现</h1><h2 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h2><p>当客户端通过一系列的配置字段（主机（host）、端口（port）、资源名称（resource name）和安全标记（secure））以及一个可被使用的协议（protocol）和扩展（extensions）列表来建立一个WebSocket连接</p><h2 id="2-关闭WebSocket连接"><a href="#2-关闭WebSocket连接" class="headerlink" title="2. 关闭WebSocket连接"></a>2. 关闭WebSocket连接</h2><h3 id="关闭原理"><a href="#关闭原理" class="headerlink" title="关闭原理"></a>关闭原理</h3><p>关闭tcp连接和tls会话。 tcp关闭才算<em><strong>彻底</strong></em></p><p>用一个状态码 <code>code</code> （第 7.4 节）和一个可选的关闭原因 <code>reason</code> （第 7.1.6 节）来<code>开始 WebSocket 关闭握手</code>，</p><p><code>WebSocket 关闭状态码</code>被默认为1005。</p><h3 id="服务端如何关闭"><a href="#服务端如何关闭" class="headerlink" title="服务端如何关闭"></a>服务端如何关闭</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613888491004-b3205912-ae69-4bb2-82c2-9410fdb212b5.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>如何管理所有的session </p><p>通过map</p><h2 id="3-WebSocket-代码实现"><a href="#3-WebSocket-代码实现" class="headerlink" title="3. WebSocket 代码实现"></a>3. WebSocket 代码实现</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig&#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    @Bean</span><br><span class="line">    public ReverseWebSocketEndpoint reverseWebSocketEndpoint() &#123;</span><br><span class="line">        return new ReverseWebSocketEndpoint();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Bean</span><br><span class="line">    public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class="line">        return new ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端建立WebSocket连接测试"><a href="#客户端建立WebSocket连接测试" class="headerlink" title="客户端建立WebSocket连接测试"></a>客户端建立WebSocket连接测试</h2><p>前端建立WebSocket连接</p><p>在浏览器控制台输入下面标红的语法即可</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885589624-6db65e08-8609-4ab2-9353-661849c64ef1.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>⚠️：同源问题</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613885652515-f90275c9-0050-46ec-84c3-a977abfc7101.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><strong>ServerEndpointExporter类代码分析</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613891579226-535abd17-59a1-467f-9828-dbfa87e0d87b.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>annotatedEndpointClasses是记录带有@<em>ServerEndpoint的类的一个集合</em></p><p>这里涉及到<strong>InitializingBean</strong>接口、<strong>WebApplicationObjectSupport</strong>类的使用</p><p><strong>WebApplicationObjectSupport类，</strong>继承此类可以获取ApplicationContext对象，调用getWebApplicationContext()获取WebApplicationContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注：spring在代码中获取bean的几种办法</span><br><span class="line">方法一：在初始化时保存ApplicationContext对象 </span><br><span class="line">方法二：通过Spring提供的utils类获取ApplicationContext对象 </span><br><span class="line">方法三：继承自抽象类ApplicationObjectSupport </span><br><span class="line">方法四：继承自抽象类WebApplicationObjectSupport </span><br><span class="line">方法五：实现接口ApplicationContextAware </span><br><span class="line">方法六：通过Spring提供的ContextLoader</span><br></pre></td></tr></table></figure><p>注：spring在代码中获取bean的几种办法</p><p>方法一：在初始化时保存ApplicationContext对象 方法二：通过Spring提供的utils类获取ApplicationContext对象 方法三：继承自抽象类ApplicationObjectSupport 方法四：继承自抽象类WebApplicationObjectSupport 方法五：实现接口ApplicationContextAware 方法六：通过Spring提供的ContextLoader</p><p><strong>InitializingBean</strong>接口为bean提供了初始化方法的方式，它只包括<strong>afterPropertiesSet方法</strong>，凡是继承该接口的类，在初始化bean的时候会执行该方法。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1613895411231-35c1eeab-3b5d-458d-bbdf-0b629cc699c3.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>工具</p><p><a href="http://coolaf.com/tool/chattest">http://coolaf.com/tool/chattest</a> 在线websocket</p><p>参考：</p><p><a href="https://www.cnblogs.com/kiwifly/p/11729304.html">https://www.cnblogs.com/kiwifly/p/11729304.html</a>  session共享问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jedis线程回收问题</title>
      <link href="2021/01/10/Jedis%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/01/10/Jedis%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问题：redis.clients.jedis.exceptions.JedisConnectionException:Could not get a resource from the pool</p></blockquote><p>查询问题原因，猜测以下几点</p><ol><li>Redis没启动</li><li>资源池参数不合理：比如QPS高，连接池小。</li><li>因为用的Jedis, jedis线程池用完了没有归还</li></ol><p>进入redis客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> info client</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Client</span></span><br><span class="line">connected_clients:628</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br></pre></td></tr></table></figure><p>查过几次连接数居高不变</p><p>config get maxclients</p><p>查询出来也没问题</p><p>然后继续查询Jedis回收问题</p><p>网上多数都说没有finnally回收</p><p>但是项目代码是有的</p><p>然后开始Debug，发现确实没有走到那步。</p><p>然后找原因发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">    jedis.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。。</p><p>这不应该是jedis.close啊，应该是jedisPool.close()啊，粗心了。</p><p>正好在这总结下jedis.close 和 jedisPool.close的区别</p><p>在jedis3.0后，jedisPool.returnResource()方法是被弃用的</p><p>….未完待续</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>socket.io服务端理解和组件分析</title>
      <link href="2020/12/10/socket-io%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%90%86%E8%A7%A3%E5%92%8C%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>2020/12/10/socket-io%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%90%86%E8%A7%A3%E5%92%8C%E7%BB%84%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾Socket"><a href="#回顾Socket" class="headerlink" title="回顾Socket"></a>回顾Socket</h2><p>Socket建立请求和处理数据的过程</p><h3 id="一个客户端"><a href="#一个客户端" class="headerlink" title="一个客户端"></a>一个客户端</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838003875-4ba0c7b8-51cb-448c-a826-f73ada176fa9.png" alt="image.png"></p><p>整个过程服务端都是一个线程在做，客户端发来请求，服务端accpet()接受请求，read(), write()处理数据， 处理完数据关闭连接、释放线程。</p><h3 id="多个客户端"><a href="#多个客户端" class="headerlink" title="多个客户端"></a>多个客户端</h3><p>如果多个客户端怎么办？</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614838158237-31c32765-eaa7-462b-b864-7b21a0a0e90a.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>那就每一个客户端创建一个线程。新建一个线程专门用来监听，有新客户端就new一个新的线程。</p><p>我们还可以优化一下，<strong>池化思想</strong>。将new Thread这个过程变成， 从pool线程池里面获取，让很多线程不随着连接关闭，多次复用。</p><p>这就出现了NIO优化的地方</p><h3 id="NIO非阻塞思想"><a href="#NIO非阻塞思想" class="headerlink" title="NIO非阻塞思想"></a>NIO非阻塞思想</h3><p>NIO 三个关键组件  Selector、Buffer、Channel</p><p>Selector有点像我们上面图的监听线程，他的作用就是从线程池里面找到空闲的线程来处理客户端的请求。</p><p>Selector充当中间分配任务的角色，所有客户端线程、服务端线程都注册到我这，我帮你们进行分配，进行多路复用。</p><p>线程池里面的线程会轮询去Selector中找感兴趣的事，不会绑定某个连接上，read()、write()事件处理完就继续找下一个连接要处理的事情，等到上一个连接有新的数据再返回处理。</p><p>Channel、Buffer改变传统流的方式，能够更好管理数据，提高效率。</p><h2 id="Netty基础概念和代码"><a href="#Netty基础概念和代码" class="headerlink" title="Netty基础概念和代码"></a>Netty基础概念和代码</h2><p>Netty就是对NIO的使用进行了简化，又优化了很多地方。但是核心思想还是不变的，还是采用Channel和Buffer这种结构。</p><p>Netty将Channel中加入ChannelHandler这种组件，它负责调度应用程序的处理逻辑，并驱动数据和事件经过网络层。简单来说就是加入了带有方向的拦截器，用来处理数据。</p><p>Buffer也变成了ByteBuf。</p><p>为了简化nio使用，Netty使用了<strong>BootStrap启动器</strong>用来辅助进行建立<strong>socket连接</strong>、<strong>创建Channel通道</strong>等等这些操作，设计模式用的是构建者模式。</p><p>同时还有<strong>EventLoop</strong>用来管理所有的Channel，这里的<strong>EventLoop</strong>可以理解为上面图的<strong>监控线程</strong>、或者是<strong>工作线程</strong>这种线程。EventLoopGroup就是线程池，所以我们的工作线程要有线程池，这就是Netty代码里面的 NioEventLoopGroup <strong>work</strong> = new NioEventLoopGroup(); 同样，如果监控线程如果监控的是一个端口可以只用一个线程、如果是多个端口那就要用线程池了。所以在Netty中就出现了boss这种线程池（NioEventLoopGroup <strong>boss</strong> = new NioEventLoopGroup(); ）</p><p>Netty的学习首先要搞清楚它的架构、设计模式。</p><p>清楚他的各个组件的作用和关系，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614835289260-6477f02f-b166-43dc-9370-441899d5f036.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>如果你认为 ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的 Channel- Handler 实例链，是ChannelHandler的容器。</p><p>Netty在Channel里传输的数据是ByteBuf，所以我们要将客户端和服务端所接受的数据都转化为ByteBuf，这就涉及到了一个Netty的重要部分，编码和解码。</p><p>还有就是ChannelHandlerContext，是ChannelHandler上下文内容，ChannelHandler处理完的数据都是ChannelHandlerContext来传输下一个ChannelHandler。ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关 联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandler- Context。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在 同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p><p>使用Netty大致的过程就是：</p><ol><li>创建Bootstrap启动器</li><li>创建监控线程组boss和工作线程组work。（客户端不用boss)</li><li>用Bootstrap建立Channel，添加ChannelHanlder拦截器</li><li>客户端用Bootstrap连接服务端。服务端用Bootstrap绑定端口开启监听</li></ol><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class NettyServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ServerBootstrap bootstrap &#x3D; new ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup work &#x3D; new NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(boss, work)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(new DecoderHandler());</span><br><span class="line">                        ch.pipeline().addLast(new ServerInHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        ChannelFuture future &#x3D; bootstrap.bind(1000).addListener((listener) -&gt; &#123;</span><br><span class="line">            if (listener.isSuccess()) &#123;</span><br><span class="line">                System.out.println(&quot;服务器启动成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># NettyClient.java</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Netty客户端</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class NettyClient &#123;</span><br><span class="line"></span><br><span class="line">    Bootstrap bootstrap &#x3D; new Bootstrap();</span><br><span class="line"></span><br><span class="line">    EventLoopGroup work;</span><br><span class="line"></span><br><span class="line">    public boolean connect(String inetHost, Integer inetPort) throws InterruptedException &#123;</span><br><span class="line">        work &#x3D; new NioEventLoopGroup();</span><br><span class="line">        bootstrap.group(work)</span><br><span class="line">                .channel(NioSocketChannel.class) &#x2F;&#x2F;</span><br><span class="line">                .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(new EncoderHandler());</span><br><span class="line">                        ch.pipeline().addLast(new ClientInHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            bootstrap.connect(inetHost, inetPort).addListener((listener) -&gt; &#123;</span><br><span class="line">                if (listener.isSuccess()) &#123;</span><br><span class="line">                    System.out.println(&quot;连接成功&quot;);</span><br><span class="line">                    ChannelFuture future &#x3D; (ChannelFuture) listener;</span><br><span class="line">                    startConsoleThread(future.channel());  &#x2F;&#x2F; 开启控制台线程</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="socketio实例分析"><a href="#socketio实例分析" class="headerlink" title="socketio实例分析"></a>socketio实例分析</h2><p>分析的是github上socketio这个项目 <a href="https://github.com/mrniko/netty-socketio/">https://github.com/mrniko/netty-socketio/</a></p><p>Socket.IO server implemented on Java. Realtime java framework</p><p>用netty实现的实时网络通信</p><h3 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h3><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>在一个命名空间空间的所有客户端都是共享的</p><p>那共享的都有什么呢？一个一个分析</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614920618711-1ada87d2-c22c-424a-a609-0c98624dbbfa.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>先看ScannerEngine类内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># ScannerEngine.class</span><br><span class="line">    </span><br><span class="line">public void scan(Namespace namespace, Object object, Class&lt;?&gt; clazz)</span><br><span class="line">            throws IllegalArgumentException &#123;</span><br><span class="line">        Method[] methods &#x3D; clazz.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 类不是Object类型的</span><br><span class="line">        if (!clazz.isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                for (AnnotationScanner annotationScanner : annotations) &#123;</span><br><span class="line">                    Annotation ann &#x3D; method.getAnnotation(annotationScanner.getScanAnnotation());</span><br><span class="line">                    if (ann !&#x3D; null) &#123;</span><br><span class="line">                        annotationScanner.validate(method, clazz);</span><br><span class="line"></span><br><span class="line">                        Method m &#x3D; findSimilarMethod(object.getClass(), method);</span><br><span class="line">                        if (m !&#x3D; null) &#123;</span><br><span class="line">                            annotationScanner.addListener(namespace, object, m, ann);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            log.warn(&quot;Method similar to &quot; + method.getName() + &quot; can&#39;t be found in &quot; + object.getClass());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; -----------------主要看这段--------------------------</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                for (AnnotationScanner annotationScanner : annotations) &#123;</span><br><span class="line">                    Annotation ann &#x3D; method.getAnnotation(annotationScanner.getScanAnnotation());</span><br><span class="line">                    if (ann !&#x3D; null) &#123;</span><br><span class="line">                        annotationScanner.validate(method, clazz);</span><br><span class="line">                        makeAccessible(method);</span><br><span class="line">                        annotationScanner.addListener(namespace, object, method, ann);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#x2F;&#x2F; -----------------end--------------------------</span><br><span class="line">            if (clazz.getSuperclass() !&#x3D; null) &#123;</span><br><span class="line">                scan(namespace, object, clazz.getSuperclass());</span><br><span class="line">            &#125; else if (clazz.isInterface()) &#123;</span><br><span class="line">                for (Class&lt;?&gt; superIfc : clazz.getInterfaces()) &#123;</span><br><span class="line">                    scan(namespace, object, superIfc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先说这段代码干嘛的，去扫描类里面的方法，有没有带有这三个注解的方法，如果有的话，把相应的下图三个监听器添加到相应命名空间下的执行队列中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921713851-7997ddad-d955-4573-b8d9-0967228615f4.png" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614921813582-a02626b3-2473-42f9-832a-0424577f9a92.png" alt="image.png"></p><p>所以ScannerEngine类就是扫描注解，然后添加监听器。加个上面三个注解的方法都会添加到监听器中。</p><p>NameSpace这个对象拿着ScannerEngine引擎去查找带注解的方法，并添加到NameSpace中。</p><p>eventListeners、connectListeners、disconnectListeners</p><p>这三个就不要特别说明了，是三个不同类别的监听器，分别在不同时期进行执行。</p><p>pingListeners也是同理</p><p>allClients是在这个命名空间下所有的客户端， SocketIOClient是客户端实体</p><p>roomClients是房间内的客户端，就算是分组把</p><p>clientRooms是房间，也就是组。可以移除客户端也可以添加。</p><h4 id="NameSpaceHub"><a href="#NameSpaceHub" class="headerlink" title="NameSpaceHub"></a>NameSpaceHub</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923575816-c1e9f0ca-b3e7-4941-84c3-85bbe741e7c1.png" alt="image.png"></p><p>用来操作NameSpaceHub的，主要是创建、获取移除等等，同时可以看到所有的NameSpace。</p><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923846574-f407d315-a478-4bcf-878d-5cbf561b1fb3.png" alt="image.png"></p><p>因为在使用Netty过程中我们要自定义协议格式，这里Packet就是数据协议包，AuthPacket是一个认证的协议包。</p><p>剩下都是围绕Packet的一些工具。比如PacketDecoder或者PacketEncoder这种编码解码工具、Json序列化的工具等等。</p><p>重点说下Packet包</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614923992993-0a7ce29c-e754-48ef-bf3c-ef7b1fae200b.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>data数据、nsp命名空间、ackId唯一标识，可能用于消息确认等其他用途、type、subType都是包的类型</p><p>包的类型又分为下面这些</p><p><em><strong>#PacketType.java</strong></em></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924404084-776ee465-968b-4e16-ab5c-0cd87dc67832.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><p>类型Connect、Disconnect或者是Event或者是Ackd等等</p><p>回到上图这个attachments我也没明白，应该是可以自定义的一些字段，附件，方便扩展。同时还需要进行初始化</p><p><em><strong>#Packet.java</strong></em></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614924500498-1170a570-9d64-40cc-89fe-535e6b8bc16c.png" alt="image.png"></p><p>Packet包里面的数据就是data，data经过***#PacketEncoder***编码后就变了ByteBuf，Netty就可以在Channel中传输了，下图是编码的过程</p><p><em><strong>#PacketEncoder.java</strong></em></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2597675/1614925102874-bfc4aba2-6291-45c2-b661-6c9f2ac75d16.png?x-oss-process=image/resize,w_1500" alt="image.png"></p><h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>…. 未完待续</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="2020/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h2><p>XA 是 X/Open CAE Specification (Distributed Transaction Processing)模型，它定义的 TM（Transaction Manager）与 RM（Resource Manager）之间进行通信的接口。</p><p><img src="http://static.iocoder.cn/c8f27f0e1107c328476600c4ed2608ec" alt="强 XA 的顺序图"></p><ul><li>二阶段提交是 XA 的标准实现。它将分布式事务的提交拆分为 2 个阶段：prepare 和 commit/rollback 。<ul><li>第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</li><li>第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。</li></ul></li><li>开启 XA 全局事务后，所有子事务会按照本地默认的隔离级别锁定资源，并记录 undo 和 redo 日志。然后由 TM 发起 prepare 投票，询问所有的子事务是否可以进行提交：<ul><li>当所有子事务反馈的结果为 “yes” 时，TM 再发起 commit 。</li><li>若其中任何一个子事务反馈的结果为“no”，TM 则发起 rollback 。</li><li>如果在 prepare 阶段的反馈结果为 “yes” ，而 commit 的过程中出现宕机等异常时，则在节点服务重启后，可根据 XA recover 再次进行 commit 补偿，以保证数据的一致性。</li></ul></li></ul><h3 id="XA出现的问题"><a href="#XA出现的问题" class="headerlink" title="XA出现的问题"></a>XA出现的问题</h3><ul><li><p>单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</p></li><li><p>同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</p></li><li><p>数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p></li></ul><p> <strong>解决方案</strong></p><ul><li><p>Sharding Sphere</p><blockquote><p>Sharding Sphere 支持基于 XA 的强一致性事务解决方案，可以通过 SPI 注入不同的第三方组件作为事务管理器实现 XA 协议，如 Atomikos 和 Narayana 。</p></blockquote></li><li><p>Spring JTA + Atomikos</p></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。</p><p>这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p><p><a href="http://static.iocoder.cn/baef17d9dde837632e9a7894cb825cb2"><img src="http://static.iocoder.cn/baef17d9dde837632e9a7894cb825cb2" alt="distributed-transacion-XA"></a>distributed-transacion-XA</p><h2 id="利用消息可靠性保证最终一致性"><a href="#利用消息可靠性保证最终一致性" class="headerlink" title="利用消息可靠性保证最终一致性"></a>利用消息可靠性保证最终一致性</h2><p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><p><a href="http://static.iocoder.cn/80a431c9be51ed67d9c67f7a1de7c2ed"><img src="http://static.iocoder.cn/80a431c9be51ed67d9c67f7a1de7c2ed" alt="distributed-transaction-reliable-message"></a></p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>RocketMQ 事务消息</li><li>RabbitMQ消息确认机制</li><li>Kafka事务消息</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka消费者</title>
      <link href="2020/11/02/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>2020/11/02/Kafka%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka消费者"><a href="#Kafka消费者" class="headerlink" title="Kafka消费者"></a>Kafka消费者</h1><p>消费者从属于消费群组</p><p>Kafka分为主题和分区，主题包括分区， 分区是个有序队列。</p><p>消费者订阅主题，处理主题里分区的消息。如果想要有序处理，那么就讲消费者和分区进行绑定。</p><h3 id="消费者、消费者群组和分区关系"><a href="#消费者、消费者群组和分区关系" class="headerlink" title="消费者、消费者群组和分区关系"></a>消费者、消费者群组和分区关系</h3><p>通常，一个主题会对应一个消费群组，消费群组的消费能力取决于消费者的个数。一个消费者对应一个分区或者多个分区。</p><p>同一个分区内的消息只能被同一个消费者群组中的一个消费者消费</p><p>但是可以被多个消费者群组消费。</p><p>消费者 &gt; 分区，消费者过多，有消费者消费能力失效</p><p>如果两个消费群组对应一个主题</p><p>消费能力就是之前的两倍，但是每个消费者群组里面依然和上面相同</p><p>当然，如果消费者能力很强，是可以处理多个分区的。</p><p>消费者群组具有伸缩读取能力和处理能力，群组里的每个消费者只处理部分消息。</p><p>如果分区的消息还没处理完，需要转移到另外一个消费者，这个过程就需要再均衡。</p><h3 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h3><p>再均衡的过程就是消费者对分区失去所有权的过程，所以再失去所有权之前要把自己处理记录的偏移量记录下来。</p><p>Kafka设计了一个再均衡监听器</p><p><em><strong>ConsumerRebalanceListener.class</strong></em> </p><p>实现接口的两个方法分别是***#onPartitionsRevoked*** 和 <em><strong>#onPartitonsAssigned</strong></em></p><p>Revoked 是消费者停止读取消息之后被调用，在这里提交最后的偏移量</p><p>Assigned 再均衡之后，消费者开始读取消息之前调用。</p><p>这里涉及到偏移量提交的问题，偏移量是如何提交的</p><p>再均衡会做一些清理工作</p><ol><li><p>关闭数据库连接</p></li><li><p>关闭文件具柄</p></li><li><p>缓冲区遗留的记录</p></li><li><p>…</p></li></ol><h3 id="偏移量的提交"><a href="#偏移量的提交" class="headerlink" title="偏移量的提交"></a>偏移量的提交</h3><h4 id="同步提交"><a href="#同步提交" class="headerlink" title="同步提交"></a>同步提交</h4><p>分为手动提交和自动提交</p><p>自动提交</p><p>每5s,消费者会自动提交</p><p>手动提交就不基于时间间隔，使用commitSync()提交偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     consumer.commitSycn();</span><br><span class="line">   &#125;<span class="keyword">catch</span>(CommitFailedException e) &#123;</span><br><span class="line">     log.error(<span class="string">&quot;commit failed&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：会限制吞吐量， 降低频率又回带来消息重复的问题</p><h4 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h4><p>commitAsync();</p><p>提交后就反回，虽然解决了上述的问题，但是也带来了新的问题，顺序问题。</p><p>如果重试会带来顺序错误问题，就会带来消息重复消费的问题。</p><p>可以通过回调的方式处理</p><p>在重试前，先检查回调的序列好和即将提交的偏移量是否相等。相等可以提交，如果序列号偏大，需要停止重试。</p><h4 id="同步和异步组合提交"><a href="#同步和异步组合提交" class="headerlink" title="同步和异步组合提交"></a>同步和异步组合提交</h4><p>提交偏移量的重点在于提交最后一个偏移量</p><p>组合提交，异步正常提交，同步进行重试</p><h4 id="提交特定偏移量"><a href="#提交特定偏移量" class="headerlink" title="提交特定偏移量"></a>提交特定偏移量</h4><p>通过map记录偏移量相关信息。</p><p>然后再通过commitAsync或者commitSync尽心提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">ConsumerRecords.class <span class="comment">//消费者记录</span></span><br><span class="line">  </span><br><span class="line">ConsumerRecord records = consumer.poll(<span class="number">100</span>); <span class="comment">//拉取100s内的数据返回消费者端</span></span><br><span class="line"></span><br><span class="line">records.forEach( record -&gt; &#123;</span><br><span class="line">  record.offset(); <span class="comment">// 偏移量</span></span><br><span class="line">  cosummer.commitAsync(...);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql下的join buffer</title>
      <link href="2020/07/10/mysql%E4%B8%8B%E7%9A%84join%20buffer/"/>
      <url>2020/07/10/mysql%E4%B8%8B%E7%9A%84join%20buffer/</url>
      
        <content type="html"><![CDATA[<p>我们在查询的时候，通过explain可以看到经常有使用join buffer（Using join buffer(Block Nested Loop)</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375660c0e7449d?w=2538&h=372&f=png&s=82383"></p><p>要想知道join buffer，就是先知道join运行的原理。</p><h2 id="嵌套循环连接（Nested-Loop-Join）"><a href="#嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="嵌套循环连接（Nested-Loop Join）"></a>嵌套循环连接（Nested-Loop Join）</h2><p><a href="https://juejin.im/book/6844733769996304392/section/6844733770055024654">详细请参考掘金小册《Mysql是怎样运行的》</a></p><p>join的原理就是嵌套循环连接，驱动表作为第一层，被驱动表作为第二层，情况基本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 驱动表的每行记录 <span class="keyword">in</span> 驱动表的记录</span><br><span class="line"><span class="keyword">for</span> 被驱动表每行记录 <span class="keyword">in</span> 被驱动表的记录</span><br><span class="line"><span class="keyword">if</span> (on条件（驱动表的每行记录，被驱动表的每行记录）？<span class="keyword">return</span> true : false</span><br></pre></td></tr></table></figure><p>时间复杂度为 count(驱动表的记录) x count(被驱动表) </p><p>比如：有一张课程表course</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">course                                teacher</span><br><span class="line">---------------------                 ------------------------</span><br><span class="line">course_id| teacher_id                 teacher_id| teacher_name</span><br><span class="line">---------------------                 ------------------------</span><br><span class="line"><span class="number">1</span>        | <span class="number">1</span>                          <span class="number">1</span>         | leo</span><br><span class="line">---------------------                 ------------------------</span><br><span class="line"><span class="number">2</span>        | <span class="number">2</span>                          <span class="number">2</span>         | john</span><br><span class="line">---------------------                 ------------------------</span><br></pre></td></tr></table></figure><p>sql语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course <span class="keyword">left</span> <span class="keyword">join</span> teacher </span><br><span class="line"><span class="keyword">on</span> course.teacher_id <span class="operator">=</span> teacher.teacher_id </span><br><span class="line"><span class="keyword">where</span> course_id <span class="operator">&gt;</span> <span class="number">0</span>。</span><br></pre></td></tr></table></figure><p>因为是左连接，cource为驱动表， teacher为被驱动表。</p><ol><li><p><strong>第一步筛选出驱动表符合条件的记录</strong></p><p>mysql 查询的时候先根据where条件进行对course的单表查询, 查询出的每一条记录都要在与teacher进行一次查询匹配。例如，where course_id &gt; 0, 那么从course表中拿到第一条记录的时候发现是&gt;0的，可以留下，然后该去teacher表中进行匹配了。</p></li><li><p><strong>通过连接条件on后的条件对被驱动表的数据筛选</strong></p><p>第一条的teacher_id 为1，on 条件为teacher_id 相等，也就是我们在teacher表中执行如下的单表查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from teacher where teacher_id = <span class="number">1</span> </span><br></pre></td></tr></table></figure><p>那么这条记录如果没有加任何索引，执行中要查询的就是这个teacher表中的所有记录。</p></li></ol><p><strong>3. 将查询的结果与驱动表进行连接并返回给客户端</strong></p><p>连接就要根据左连接还是右连接进行匹配了，没有的加null值，等等。</p><h2 id="基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="基于块的嵌套循环连接（Block Nested-Loop Join）"></a>基于块的嵌套循环连接（Block Nested-Loop Join）</h2><p>这样一条一条的查就像双重循环，效率低下，被驱动表如果数据量大会出现性能瓶颈。</p><p>我们可以思考几个问题：</p><ul><li>每一条驱动表的记录去被驱动表进行条件匹配的时候，重复匹配了多次，我们是否加个缓存来解决？</li><li>缓存的目的是什么？</li><li>如果加缓存，这个缓存应该加在哪，驱动表还是被驱动表？</li></ul><p>首先我们加缓存的目的是为了取一次数据尽量不被舍弃，可以多次复用。我们查询了很多次被驱动表，如果查询了一次就被缓存下来，在内存中进行数据的匹配操作，效率会高很多。但是会出现一个问题，被驱动表往往是数据量大的一方，被驱动表也可以是多个。所以缓存被驱动表到内存不现实。我们可以反向来想，缓存驱动表。将驱动表的筛选出的所有数据进行缓存，然后每次从被驱动表拿来的数据都与缓存的驱动表的所有记录进行匹配，符合条件的都留下来。这样被驱动表的每条记录只取一次就可以了。</p><p>所以join_buffer 就是这个缓冲区，join buffer就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配。join_buffer 就是这个内存块。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/1737563b590bb0c5?w=826&h=479&f=png&s=104174"></p><p>复杂度也从O(n^2) 变成了 O(n)</p><h2 id="MySQL如何使用联接缓冲区缓存"><a href="#MySQL如何使用联接缓冲区缓存" class="headerlink" title="MySQL如何使用联接缓冲区缓存"></a>MySQL如何使用联接缓冲区缓存</h2><p>上面所有说的过程都是在被驱动表查询类型是ALL或者Index, 也就是进行全盘扫描，没有加索引，也不是等值连接这种情况下。</p><p><a href="https://dev.mysql.com/doc/internals/en/join-buffer-size.html">官方文档定义</a>：</p><p>Basic information about the join buffer cache:</p><ul><li>The size of each join buffer is determined by the value of the <code>join_buffer_size</code> system variable.</li><li><em><strong>This buffer is used only when the join is of type <code>ALL</code> or <code>index</code> (in other words, when no possible keys can be used).</strong></em></li><li>A join buffer is never allocated for the first non-const table, even if it would be of type <code>ALL</code> or <code>index</code>.</li><li>The buffer is allocated when we need to do a full join between two tables, and freed after the query is done.</li><li>Accepted row combinations of tables before the <code>ALL</code>/<code>index</code> are stored in the cache and are used to compare against each read row in the <code>ALL</code> table.</li><li><em><strong>We only store the used columns in the join buffer, not the whole rows.</strong></em></li></ul><p>上面说，仅仅是在type 为ALL 或者 index 条件下，为什么？</p><p>当然是因为使用其他计算方法效率更高，比如我们驱动表进行条件筛选的时候，where teacher_id =1 , 给teacher_id 加上索引就不需要筛选被驱动表中的所有数据，这样的效率更高。只有在Mysql优化器认定type为ALL的时候才<strong>可能</strong>会去用join_buffer</p><p>最后一句说：我们仅仅存储使用到的列，而不是整个行</p><p>join_buffer存储的是驱动表中用到的列的数据，比如course表，记录还是两条，但是每条记录里只有teacher_id而没有course_id。</p><p>所以要纠正一下上文中的说话，比如记录啊、每一行并不是真的指行里所有的数据，只是需要用到的列的数据。</p><p>在看下官方的定义的执行步骤：</p><p>假设您具有以下联接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> name      Type</span><br><span class="line">t1              <span class="keyword">range</span></span><br><span class="line">t2              <span class="keyword">ref</span></span><br><span class="line">t3              <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p>然后按以下步骤完成连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> While <span class="keyword">rows</span> <span class="keyword">in</span> t1 matching <span class="keyword">range</span></span><br><span class="line"> <span class="operator">-</span> Read through <span class="keyword">all</span> <span class="keyword">rows</span> <span class="keyword">in</span> t2 according <span class="keyword">to</span> reference key</span><br><span class="line">  <span class="operator">-</span> Store used fields <span class="keyword">from</span> t1, t2 <span class="keyword">in</span> cache</span><br><span class="line">  <span class="operator">-</span> If cache <span class="keyword">is</span> <span class="keyword">full</span></span><br><span class="line">    <span class="operator">-</span> Read through <span class="keyword">all</span> <span class="keyword">rows</span> <span class="keyword">in</span> t3</span><br><span class="line">      <span class="operator">-</span> Compare t3 <span class="type">row</span> against <span class="keyword">all</span> t1, t2 combinations <span class="keyword">in</span> cache</span><br><span class="line">        <span class="operator">-</span> If <span class="type">row</span> satisfies <span class="keyword">join</span> <span class="keyword">condition</span>, send it <span class="keyword">to</span> client</span><br><span class="line">    <span class="operator">-</span> <span class="keyword">Empty</span> cache</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> Read through <span class="keyword">all</span> <span class="keyword">rows</span> <span class="keyword">in</span> t3</span><br><span class="line"> <span class="operator">-</span> Compare t3 <span class="type">row</span> against <span class="keyword">all</span> stored t1, t2 combinations <span class="keyword">in</span> cache</span><br><span class="line">   <span class="operator">-</span> If <span class="type">row</span> satisfies <span class="keyword">join</span> <span class="keyword">condition</span>, send it <span class="keyword">to</span> client</span><br></pre></td></tr></table></figure><p>前面的描述意味着<code>t3</code>扫描表的次数 确定如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S <span class="operator">=</span> size<span class="operator">-</span><span class="keyword">of</span><span class="operator">-</span>stored<span class="operator">-</span><span class="type">row</span>(t1,t2)</span><br><span class="line">C <span class="operator">=</span> accepted<span class="operator">-</span><span class="type">row</span><span class="operator">-</span>combinations(t1,t2)</span><br><span class="line">scans <span class="operator">=</span> (S <span class="operator">*</span> C)<span class="operator">/</span>join_buffer_size <span class="operator">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>t1 range ,t2 ref ，所以这部分没有用join_buffer，而是将t1和t2匹配的结果缓存在缓冲区</p><p><a href=""></a></p><p>t3 为all, 读取的时候拿出t3的每一行与t1和t2缓存进行比较。</p><p><a href=""></a></p><p>扫描的行数为</p><p>scans = (S * C)/join_buffer_size + 1</p><p>这个join_buffer 也是有一定大小的，如果驱动表&gt; join_buffer，就需要分多次。所以上面要除以/join_buffer_size</p><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><p>Some conclusions:</p><ul><li><p>The larger the value of <code>join_buffer_size</code>, the fewer the scans of <code>t3</code>. If <code>join_buffer_size</code> is already large enough to hold all previous row combinations, there is no speed to be gained by making it larger.</p></li><li><p>If there are several tables of join type <code>ALL</code> or <code>index</code>, then we allocate one buffer of size <code>join_buffer_size</code> for each of them and use the same algorithm described above to handle it. (In other words, we store the same row combination several times into different buffers.)</p></li><li><p>值越大<code>join_buffer_size</code>，扫描的次数越少<code>t3</code>。如果 <code>join_buffer_size</code>已经足够大以容纳所有先前的行组合，则使其变大无法获得任何速度。</p></li><li><p>如果有多个联接类型为<code>ALL</code>或的表<code>index</code>，则我们<code>join_buffer_size</code>为每个表 分配一个大小相同的缓冲区， 并使用上述相同的算法进行处理。（换句话说，我们将同一行组合多次存储到不同的缓冲区中。）</p></li></ul><p><strong>参考 《MySQL 是怎样运行的：从根儿上理解 MySQL》 作者:小孩子4919</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Volatile的一些理解</title>
      <link href="2020/06/12/Volatile/"/>
      <url>2020/06/12/Volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="Volatile的一些理解"><a href="#Volatile的一些理解" class="headerlink" title="Volatile的一些理解"></a>Volatile的一些理解</h1><p>线程的实时可见性</p><p>禁止指令重排</p><p>为什么要了解透彻一些呢，因为用错过。。。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>先说可见性，指的是当一条线程修改了带有volatile变量的值，新值对于其他所有线程是立即可见的。</p><p>对于正常的变量来说，变量修改完变量的值后，需要通过主内存进行传递，其他线程才知道被更改了。</p><p>volatile变量也可以存在不一致的情况，由于每次使用之前都要刷新，所以是看不到不一致的情况。</p><p>原子性操作好的是没问题的，但是非原子性操作还是会出现问题。</p><p>比如我们常说的 a++ ,其实不是原子性操作，这个应该都知道。</p><p>如果在a++这个过程中发生了并发问题，volatile变量被赋值的时候仍然会出问题</p><blockquote><ol><li>运算结果并不依赖变量的当前值、或者确保只有单一的线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ol></blockquote><h2 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h2><p>java是线程内表现为串行化，但实际执行并非按照编排的指令顺序执行。</p><p>如果多个线程就会出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> flag = true;会被优化，会被提前执行，加了volitile就不会被优化。</p><p>我们如果单线程的话，这个success是永远的都不会反回，返回success。java单线程是保证串行化的。</p><p>当然，如果多线程，每个线程都是按照这个顺序来也都是不会返回的，flag=true都是后执行。</p><p>Volatile性能要比锁高很多。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
