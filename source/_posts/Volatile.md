---
title: mysql下的join buffer
date: 2020-06-12
tags: 并发
---

# Volatile的一些理解

线程的实时可见性

禁止指令重排



为什么要了解透彻一些呢，因为用错过。。。

## 可见性

先说可见性，指的是当一条线程修改了带有volatile变量的值，新值对于其他所有线程是立即可见的。

对于正常的变量来说，变量修改完变量的值后，需要通过主内存进行传递，其他线程才知道被更改了。



volatile变量也可以存在不一致的情况，由于每次使用之前都要刷新，所以是看不到不一致的情况。



原子性操作好的是没问题的，但是非原子性操作还是会出现问题。

比如我们常说的 a++ ,其实不是原子性操作，这个应该都知道。

如果在a++这个过程中发生了并发问题，volatile变量被赋值的时候仍然会出问题



> 1. 运算结果并不依赖变量的当前值、或者确保只有单一的线程修改变量的值
> 2. 变量不需要与其他的状态变量共同参与不变约束。



## 禁止指令重排



java是线程内表现为串行化，但实际执行并非按照编排的指令顺序执行。

如果多个线程就会出现



```java
class A {
  
 	boolean flag = false;
  
  public String test() {
   ....
   flag = true;
   while(!flag) {
      return "success";
   }
  } 
}
```

 flag = true;会被优化，会被提前执行，加了volitile就不会被优化。



我们如果单线程的话，这个success是永远的都不会反回，返回success。java单线程是保证串行化的。

当然，如果多线程，每个线程都是按照这个顺序来也都是不会返回的，flag=true都是后执行。



Volatile性能要比锁高很多。