---
title: Kafka消费者
date: 2020-11-02
tags: Kafka
---



# Kafka消费者

消费者从属于消费群组

Kafka分为主题和分区，主题包括分区， 分区是个有序队列。

消费者订阅主题，处理主题里分区的消息。如果想要有序处理，那么就讲消费者和分区进行绑定。



### 消费者、消费者群组和分区关系

通常，一个主题会对应一个消费群组，消费群组的消费能力取决于消费者的个数。一个消费者对应一个分区或者多个分区。

同一个分区内的消息只能被同一个消费者群组中的一个消费者消费

但是可以被多个消费者群组消费。

消费者 > 分区，消费者过多，有消费者消费能力失效

如果两个消费群组对应一个主题

消费能力就是之前的两倍，但是每个消费者群组里面依然和上面相同

当然，如果消费者能力很强，是可以处理多个分区的。



消费者群组具有伸缩读取能力和处理能力，群组里的每个消费者只处理部分消息。

如果分区的消息还没处理完，需要转移到另外一个消费者，这个过程就需要再均衡。



### 再均衡

再均衡的过程就是消费者对分区失去所有权的过程，所以再失去所有权之前要把自己处理记录的偏移量记录下来。

Kafka设计了一个再均衡监听器

***ConsumerRebalanceListener.class*** 

实现接口的两个方法分别是***#onPartitionsRevoked*** 和 ***#onPartitonsAssigned***

Revoked 是消费者停止读取消息之后被调用，在这里提交最后的偏移量

Assigned 再均衡之后，消费者开始读取消息之前调用。

这里涉及到偏移量提交的问题，偏移量是如何提交的



再均衡会做一些清理工作

1. 关闭数据库连接

2. 关闭文件具柄

3. 缓冲区遗留的记录

4. ...

   

### 偏移量的提交

#### 同步提交

分为手动提交和自动提交

自动提交

每5s,消费者会自动提交

手动提交就不基于时间间隔，使用commitSync()提交偏移量。

```java
while(true) {
   try {
     consumer.commitSycn();
   }catch(CommitFailedException e) {
     log.error("commit failed", e);
   }
}
```



缺点：会限制吞吐量， 降低频率又回带来消息重复的问题

#### 异步提交

commitAsync();

提交后就反回，虽然解决了上述的问题，但是也带来了新的问题，顺序问题。

如果重试会带来顺序错误问题，就会带来消息重复消费的问题。



可以通过回调的方式处理

在重试前，先检查回调的序列好和即将提交的偏移量是否相等。相等可以提交，如果序列号偏大，需要停止重试。



#### 同步和异步组合提交

提交偏移量的重点在于提交最后一个偏移量

组合提交，异步正常提交，同步进行重试



#### 提交特定偏移量

通过map记录偏移量相关信息。

然后再通过commitAsync或者commitSync尽心提交



```java


ConsumerRecords.class //消费者记录
  
ConsumerRecord records = consumer.poll(100); //拉取100s内的数据返回消费者端

records.forEach( record -> {
  record.offset(); // 偏移量
  cosummer.commitAsync(...);
});



```







